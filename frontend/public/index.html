<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StackBill Deployment Center</title>
    <link rel="stylesheet" href="/css/styles.css">
    <style>
        /* Index-specific styles - Step Cards & Wizard Components */

        /* Legacy color variable aliases for dark mode compatibility */
        :root {
            --gray-50: var(--color-gray-50);
            --gray-100: var(--color-gray-100);
            --gray-200: var(--color-gray-200);
            --gray-300: var(--color-gray-300);
            --gray-400: var(--color-gray-400);
            --gray-500: var(--color-text-muted);
            --gray-600: var(--color-text-secondary);
            --gray-700: var(--color-text-secondary);
            --gray-800: var(--color-text-primary);
            --gray-900: var(--color-text-primary);
            --primary: var(--color-primary-500);
        }

        /* Progress Steps in Header */
        .progress-steps {
            display: flex;
            align-items: center;
            gap: 0;
            overflow-x: auto;
            padding-bottom: 5px;
        }

        .progress-step {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .step-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .step-circle.completed {
            background: var(--color-success-500);
            color: white;
        }

        .step-circle.active {
            background: white;
            color: var(--color-primary-500);
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }

        .step-circle.locked {
            background: rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.6);
        }

        .step-label {
            font-size: 0.7rem;
            margin-left: 6px;
            white-space: nowrap;
            opacity: 0.9;
        }

        .step-connector {
            width: 30px;
            height: 2px;
            background: rgba(255,255,255,0.3);
            margin: 0 5px;
        }

        .step-connector.completed {
            background: var(--color-success-500);
        }

        /* Step Cards Grid */
        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .step-card {
            background: var(--color-bg-card);
            border-radius: var(--radius-lg);
            padding: var(--space-5);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            transition: all var(--transition-base);
            border: 2px solid transparent;
            position: relative;
        }

        .step-card:hover:not(.locked) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .step-card.active {
            border-color: var(--color-primary-500);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .step-card.completed {
            border-color: var(--color-success-500);
            background: var(--gradient-success);
        }

        .step-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .step-card.locked::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
        }

        .step-card-header {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-2);
        }

        .step-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: var(--color-gray-100);
        }

        .step-card.completed .step-icon {
            background: var(--color-success-500);
            color: white;
        }

        .step-card.active .step-icon {
            background: var(--color-primary-500);
            color: white;
        }

        .step-number {
            font-size: var(--font-size-xs);
            color: var(--color-text-muted);
            font-weight: 600;
        }

        .step-title {
            font-size: var(--font-size-base);
            font-weight: 600;
            color: var(--color-text-primary);
        }

        .step-description {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            line-height: 1.4;
        }

        .step-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: var(--space-3);
            padding: 4px 10px;
            border-radius: var(--radius-full);
            font-size: var(--font-size-xs);
            font-weight: 600;
        }

        .step-status.pending {
            background: var(--color-gray-100);
            color: var(--color-text-muted);
        }

        .step-status.active {
            background: rgba(102, 126, 234, 0.1);
            color: var(--color-primary-500);
        }

        .step-status.completed {
            background: rgba(16, 185, 129, 0.1);
            color: var(--color-success-500);
        }

        .step-status.locked {
            background: var(--color-gray-100);
            color: var(--color-gray-400);
        }

        /* Active Panel */
        .active-panel {
            background: var(--color-bg-card);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            display: none;
        }

        .active-panel.visible {
            display: block;
        }

        .panel-header {
            background: var(--gradient-primary);
            color: white;
            padding: var(--space-5) var(--space-6);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h2 {
            font-size: var(--font-size-xl);
            font-weight: 600;
        }

        .panel-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background var(--transition-fast);
        }

        .panel-close:hover {
            background: rgba(255,255,255,0.3);
        }

        .panel-content {
            padding: var(--space-6);
        }

        /* Server Cards */
        .servers-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .server-card {
            background: var(--color-gray-50);
            border: 2px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-4);
        }

        .server-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }

        .server-role {
            font-weight: 600;
            color: var(--color-text-secondary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .server-role-badge {
            background: var(--color-primary-500);
            color: white;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        .add-server-btn {
            background: var(--color-gray-100);
            border: 2px dashed var(--color-gray-300);
            color: var(--color-text-secondary);
            padding: var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: var(--font-size-sm);
            font-weight: 500;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
        }

        .add-server-btn:hover {
            background: var(--color-gray-200);
            border-color: var(--color-gray-400);
        }

        /* Remove Server Button */
        .remove-server-btn {
            background: transparent;
            border: 1px solid var(--color-error-500);
            color: var(--color-error-500);
            padding: 6px 12px;
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .remove-server-btn:hover {
            background: var(--color-error-500);
            color: white;
        }

        /* Server Card Collapsible */
        .server-card {
            background: var(--color-bg-card);
            border: 2px solid var(--color-border);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .server-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4);
            cursor: pointer;
            background: var(--color-gray-50);
            border-bottom: 1px solid var(--color-border);
            transition: background var(--transition-fast);
        }

        .server-card-header:hover {
            background: var(--color-gray-100);
        }

        .server-card.collapsed .server-card-header {
            border-bottom: none;
        }

        .server-card-body {
            padding: var(--space-4);
            display: block;
        }

        .server-card.collapsed .server-card-body {
            display: none;
        }

        .server-role {
            font-weight: 600;
            color: var(--color-text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .server-role-badge {
            background: var(--color-primary-500);
            color: white;
            padding: 4px 10px;
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .server-toggle-icon {
            color: var(--color-text-muted);
            transition: transform var(--transition-fast);
            font-size: 1.2rem;
        }

        .server-card.collapsed .server-toggle-icon {
            transform: rotate(-90deg);
        }

        .server-header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--color-gray-100);
            border-radius: var(--radius-md);
            padding: 4px;
            gap: 4px;
        }

        .mode-option {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: transparent;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            color: var(--color-text-secondary);
        }

        .mode-option.active {
            background: var(--color-bg-card);
            color: var(--color-primary-500);
            box-shadow: var(--shadow-md);
        }

        /* Mode Card - Deployment Mode Selection */
        .mode-card {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            padding: 16px;
            border-radius: 10px;
            border: 2px solid var(--color-border);
            background: var(--color-bg-card);
            transition: all 0.2s;
        }

        .mode-card:hover {
            border-color: var(--color-primary-300);
        }

        .mode-card.selected {
            border-color: var(--color-primary-500);
            background: var(--color-primary-50);
        }

        .mode-card-title {
            font-weight: 600;
            color: var(--color-text-primary);
            font-size: 0.95rem;
        }

        .mode-card-desc {
            font-size: 0.8rem;
            color: var(--color-text-muted);
            margin-top: 4px;
        }

        /* Radio Group - Professional SSH Options */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .radio-group.horizontal {
            flex-direction: row;
            gap: var(--space-4);
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--color-bg-card);
        }

        .radio-option:hover {
            border-color: var(--color-primary-500);
            background: rgba(102, 126, 234, 0.02);
        }

        .radio-option.selected {
            border-color: var(--color-primary-500);
            background: rgba(102, 126, 234, 0.05);
        }

        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: var(--color-primary-500);
            cursor: pointer;
            margin: 0;
        }

        .radio-option-content {
            flex: 1;
        }

        .radio-option-label {
            font-weight: 500;
            color: var(--color-text-primary);
            font-size: var(--font-size-sm);
        }

        .radio-option-desc {
            font-size: var(--font-size-xs);
            color: var(--color-text-muted);
            margin-top: 2px;
        }

        .radio-option-icon {
            font-size: 1.2rem;
            opacity: 0.7;
        }

        /* Compact radio for inline use */
        .radio-inline {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .radio-inline input[type="radio"] {
            width: 16px;
            height: 16px;
            accent-color: var(--color-primary-500);
            margin: 0;
        }

        /* Submit Button */
        .submit-btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: var(--space-3) var(--space-6);
            border-radius: var(--radius-md);
            font-size: var(--font-size-base);
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all var(--transition-base);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .submit-btn:disabled {
            background: var(--color-gray-300);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Progress Section */
        .progress-section {
            margin-top: var(--space-6);
            border-top: 1px solid var(--color-border);
            padding-top: var(--space-5);
            display: none;
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }

        .progress-title {
            font-weight: 600;
            color: var(--color-text-secondary);
        }

        .progress-percentage {
            font-weight: 600;
            color: var(--color-primary-500);
        }

        .progress-bar {
            height: 8px;
            background: var(--color-gray-200);
            border-radius: var(--radius-sm);
            overflow: hidden;
            margin-bottom: var(--space-4);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary-500), var(--color-secondary-500));
            border-radius: var(--radius-sm);
            transition: width var(--transition-base);
        }

        .task-list {
            max-height: 350px;
            overflow-y: auto;
        }

        /* Task Item Wrapper */
        .task-item-wrapper {
            margin-bottom: 2px;
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
        }

        .task-icon {
            flex-shrink: 0;
            width: 20px;
            text-align: center;
            font-size: 1rem;
        }

        .task-name {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .task-badge {
            flex-shrink: 0;
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 4px;
            background: var(--color-gray-100);
            color: var(--color-text-muted);
        }

        .task-item.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--color-success-500);
        }

        .task-item.success .task-badge {
            background: rgba(16, 185, 129, 0.15);
            color: var(--color-success-600);
        }

        .task-item.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--color-error-500);
        }

        .task-item.error .task-badge {
            background: rgba(239, 68, 68, 0.15);
            color: var(--color-error-600);
        }

        .task-item.pending {
            background: var(--color-gray-100);
            color: var(--color-text-secondary);
        }

        .task-item.running {
            background: rgba(102, 126, 234, 0.1);
            color: var(--color-primary-600);
        }

        .task-item.running .task-icon {
            animation: spin 1s linear infinite;
        }

        .task-item.running .task-badge {
            background: rgba(102, 126, 234, 0.15);
            color: var(--color-primary-600);
        }

        .task-item.skipped {
            background: var(--color-gray-100);
            color: var(--color-gray-400);
        }

        .task-item.skipped .task-badge {
            background: var(--color-gray-200);
            color: var(--color-gray-500);
        }

        .task-failure-details {
            display: none;
            padding: 4px 14px 8px 44px;
            font-size: 0.8rem;
            color: var(--color-error-500);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Credentials Section */
        .credentials-section {
            margin-top: var(--space-5);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: var(--radius-md);
            padding: var(--space-4);
            display: none;
        }

        .credentials-section.visible {
            display: block;
        }

        .credentials-title {
            font-weight: 600;
            color: #0369a1;
            margin-bottom: var(--space-3);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .credential-row {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2);
            background: var(--color-bg-card);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
        }

        .credential-label {
            font-weight: 500;
            color: var(--color-text-secondary);
            min-width: 100px;
        }

        .credential-value {
            flex: 1;
            font-family: var(--font-family-mono);
            background: var(--color-gray-100);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-sm);
        }

        /* Summary Sidebar */
        .summary-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--color-bg-card);
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            z-index: var(--z-sidebar);
            transition: right var(--transition-base);
            display: flex;
            flex-direction: column;
        }

        .summary-sidebar.open {
            right: 0;
        }

        .summary-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: calc(var(--z-sidebar) - 1);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-base);
        }

        .summary-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .summary-header {
            background: var(--gradient-primary);
            color: white;
            padding: var(--space-5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .summary-header h3 {
            font-size: var(--font-size-lg);
        }

        .summary-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 1.2rem;
        }

        .summary-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-5);
        }

        .summary-section {
            margin-bottom: var(--space-6);
        }

        .summary-section-title {
            font-size: var(--font-size-xs);
            font-weight: 600;
            color: var(--color-text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-3);
        }

        .summary-step {
            display: flex;
            align-items: flex-start;
            gap: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
            background: var(--color-gray-50);
        }

        .summary-step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-size-xs);
            flex-shrink: 0;
        }

        .summary-step-icon.completed {
            background: var(--color-success-500);
            color: white;
        }

        .summary-step-icon.pending {
            background: var(--color-gray-300);
            color: white;
        }

        .summary-step-icon.active {
            background: var(--color-primary-500);
            color: white;
        }

        .summary-step-info {
            flex: 1;
        }

        .summary-step-name {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--color-text-primary);
        }

        .summary-step-details {
            font-size: var(--font-size-xs);
            color: var(--color-text-muted);
            margin-top: 2px;
        }

        .summary-credentials {
            background: var(--color-gray-50);
            border-radius: var(--radius-md);
            padding: var(--space-4);
        }

        .summary-cred-item {
            margin-bottom: var(--space-4);
        }

        .summary-cred-item:last-child {
            margin-bottom: 0;
        }

        .summary-cred-service {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
            margin-bottom: var(--space-2);
        }

        .summary-cred-row {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-size-sm);
            padding: var(--space-1) 0;
        }

        .summary-cred-label {
            color: var(--color-text-muted);
        }

        .summary-cred-value {
            font-family: var(--font-family-mono);
            color: var(--color-text-primary);
        }

        .summary-footer {
            padding: var(--space-5);
            border-top: 1px solid var(--color-border);
            display: flex;
            gap: var(--space-3);
        }

        .summary-btn {
            flex: 1;
            padding: var(--space-3);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all var(--transition-fast);
        }

        .summary-btn.primary {
            background: var(--color-primary-500);
            color: white;
            border: none;
        }

        .summary-btn.secondary {
            background: var(--color-bg-card);
            color: var(--color-text-secondary);
            border: 2px solid var(--color-border);
        }

        /* Summary Actions */
        .summary-actions {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--color-border);
        }

        .summary-action-btns {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .summary-action-btns .btn {
            justify-content: center;
        }

        /* Summary Session Info */
        .summary-session-info {
            background: rgba(102, 126, 234, 0.05);
            padding: var(--space-3);
            border-radius: var(--radius-md);
        }

        .summary-session-details {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .summary-session-details > div {
            margin-bottom: var(--space-1);
        }

        .summary-mode-toggle {
            margin-top: var(--space-3);
            padding-top: var(--space-3);
            border-top: 1px solid rgba(102, 126, 234, 0.2);
        }

        .summary-mode-title {
            font-size: var(--font-size-xs);
            font-weight: 600;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-2);
        }

        .summary-mode-options {
            display: flex;
            gap: var(--space-2);
        }

        .summary-mode-option {
            display: flex;
            align-items: center;
            gap: var(--space-1);
            cursor: pointer;
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
            background: var(--color-bg-card);
            transition: all var(--transition-fast);
        }

        .summary-mode-option:hover {
            border-color: var(--color-primary-400);
        }

        .summary-mode-option.active {
            border-color: var(--color-primary-500);
            background: rgba(102, 126, 234, 0.1);
        }

        .summary-mode-option input {
            margin: 0;
        }

        .summary-mode-option span {
            font-size: var(--font-size-xs);
        }

        .summary-mode-hint {
            font-size: var(--font-size-xs);
            color: var(--color-text-muted);
            margin-top: var(--space-2);
        }

        /* Result Messages */
        .result-message {
            padding: var(--space-4);
            border-radius: var(--radius-md);
            margin-top: var(--space-4);
            display: none;
        }

        .result-message.visible {
            display: block;
        }

        .result-message.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--color-success-500);
            color: #065f46;
        }

        .result-message.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--color-error-500);
            color: #991b1b;
        }

        /* Share modal specific styles */
        .share-export-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: var(--radius-lg);
            padding: var(--space-5);
            margin-bottom: var(--space-5);
            border: 2px solid var(--color-primary-500);
        }

        .share-export-title {
            font-size: var(--font-size-base);
            color: var(--color-primary-600);
            margin-bottom: var(--space-3);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .share-section-desc {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            margin-bottom: var(--space-3);
        }

        .share-details-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-3);
        }

        .share-detail-label {
            color: var(--color-text-muted);
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            margin-bottom: var(--space-1);
        }

        .share-detail-value {
            font-weight: var(--font-weight-semibold);
        }

        /* Step progress badges */
        .step-badges {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
            margin-top: var(--space-4);
        }

        .step-badge {
            padding: var(--space-1) var(--space-3);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
        }

        .step-badge.completed {
            background: var(--color-success-500);
            color: white;
        }

        .step-badge.current {
            background: var(--color-primary-500);
            color: white;
        }

        .step-badge.pending {
            background: var(--color-gray-200);
            color: var(--color-gray-500);
        }

        @media (max-width: 767px) {
            .share-details-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .steps-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .summary-sidebar {
                width: 100%;
                right: -100%;
            }

            .progress-steps {
                display: none;
            }
        }

        /* Lock icon */
        .lock-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1rem;
            z-index: 1;
        }

        /* Session info badge in header */
        .session-info {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            background: rgba(255, 255, 255, 0.1);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .session-info-label {
            font-size: var(--font-size-xs);
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .session-info-name {
            display: flex;
            align-items: center;
            gap: var(--space-1);
            background: none;
            border: none;
            color: white;
            font-weight: 600;
            font-size: var(--font-size-sm);
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .session-info-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .session-info-name .edit-icon {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        .session-info-name:hover .edit-icon {
            opacity: 1;
        }

        /* Header outline button variant */
        .header-btn-outline {
            background: transparent !important;
            border: 1px solid rgba(255, 255, 255, 0.4) !important;
        }

        .header-btn-outline:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.6) !important;
        }

        /* Main container */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-8);
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--space-8);
        }

        @media (max-width: 768px) {
            .main-container {
                padding: var(--space-5);
            }
        }
    </style>
</head>
<body>
    <!-- Header with Progress -->
    <header class="header">
        <div class="header-content">
            <div class="header-top">
                <a href="/sessions.html" class="logo" aria-label="StackBill Deployment Center">
                    <div class="logo-icon">&#9881;</div>
                    <span class="logo-text">StackBill Deployment Center</span>
                </a>
                <nav class="header-nav" aria-label="Session actions">
                    <div class="session-info" id="sessionBadge">
                        <span class="session-info-label">Session:</span>
                        <button class="session-info-name" id="sessionNameDisplay" onclick="showRenameSessionModal()" title="Click to rename">
                            Loading...
                            <span class="edit-icon">&#9998;</span>
                        </button>
                    </div>
                    <button class="header-btn" onclick="shareSession()" title="Share session">
                        <span>&#128279;</span>
                        <span class="btn-text">Share</span>
                    </button>
                    <a href="/sessions.html" class="header-btn" title="All sessions">
                        <span>&#128193;</span>
                        <span class="btn-text">Sessions</span>
                    </a>
                    <button class="header-btn header-btn-outline" onclick="toggleSummary()" title="View summary">
                        <span>&#9776;</span>
                        <span class="btn-text">Summary</span>
                    </button>
                    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode" title="Toggle dark mode" tabindex="0">
                        <div class="theme-toggle-track">
                            <div class="theme-toggle-thumb">
                                <span class="icon-sun">&#9728;</span>
                                <span class="icon-moon">&#9790;</span>
                            </div>
                        </div>
                    </button>
                </nav>
            </div>
            <div class="progress-steps" id="progressSteps" role="navigation" aria-label="Deployment progress">
                <!-- Generated by JS -->
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-container">
        <!-- Steps Grid -->
        <section class="steps-grid" id="stepsGrid">
            <!-- Generated by JS -->
        </section>

        <!-- Active Step Panel -->
        <section class="active-panel" id="activePanel">
            <div class="panel-header">
                <h2 id="panelTitle">Step Configuration</h2>
                <button class="panel-close" onclick="closePanel()">&times;</button>
            </div>
            <div class="panel-content" id="panelContent">
                <!-- Dynamic form content -->
            </div>
        </section>
    </main>

    <!-- Summary Sidebar -->
    <div class="summary-overlay" id="summaryOverlay" onclick="toggleSummary()"></div>
    <aside class="summary-sidebar" id="summarySidebar">
        <div class="summary-header">
            <h3>Deployment Summary</h3>
            <button class="summary-close" onclick="toggleSummary()">&times;</button>
        </div>
        <div class="summary-content" id="summaryContent">
            <!-- Generated by JS -->
        </div>
        <div class="summary-footer">
            <button class="summary-btn secondary" onclick="exportCredentials()">
                <span>&#128203;</span> Export All
            </button>
            <button class="summary-btn primary" onclick="saveProgress()">
                <span>&#128190;</span> Save Progress
            </button>
        </div>
    </aside>

    <!-- Rename Session Modal -->
    <div id="renameSessionModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="renameModalTitle">
        <div class="modal modal-sm">
            <div class="modal-header">
                <h3 id="renameModalTitle" class="modal-title">Rename Session</h3>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <input type="text" id="renameSessionInput" class="form-control" placeholder="Enter session name" autocomplete="off">
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="hideRenameSessionModal()" class="btn btn-secondary">Cancel</button>
                <button onclick="confirmRenameSession()" class="btn btn-primary">Save</button>
            </div>
        </div>
    </div>

    <!-- Share Session Modal -->
    <div id="shareModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="shareModalTitle">
        <div class="modal modal-lg">
            <div class="modal-header">
                <h2 class="modal-title" id="shareModalTitle">
                    <span>&#128279;</span> Share Session
                </h2>
                <button class="modal-close" onclick="hideShareModal()" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <p class="text-secondary mb-4">
                    Share this session with another machine. Export the session file and import it on the target machine.
                </p>

                <!-- Export Section -->
                <div class="share-export-section">
                    <h4 class="share-export-title">
                        <span>&#8595;</span> Export Session File
                    </h4>
                    <p class="share-section-desc">
                        Download the complete session including all servers, credentials, and progress. Import this file on another machine to continue.
                    </p>
                    <button onclick="exportFullSession()" class="btn btn-primary btn-block btn-lg">
                        <span>&#128190;</span> Download Session File (.json)
                    </button>
                </div>

                <!-- Session Details -->
                <div class="card card-body-sm bg-gray-50 mb-4">
                    <h4 class="text-sm font-semibold text-secondary mb-3">Session Details</h4>
                    <div id="shareSessionDetails" class="text-sm text-secondary"></div>
                </div>

                <!-- Additional Options -->
                <details class="mb-4">
                    <summary class="cursor-pointer font-semibold text-secondary py-2">
                        Additional Options
                    </summary>
                    <div class="mt-3">
                        <div class="form-group">
                            <label class="form-label">Session URL (same network only)</label>
                            <div class="flex gap-2">
                                <input type="text" id="shareUrl" readonly class="form-control form-control-mono text-sm">
                                <button onclick="copyShareUrl()" class="btn btn-secondary">Copy</button>
                            </div>
                            <p class="form-help">Only works if both machines access the same server</p>
                        </div>

                        <button onclick="copyFullDetails()" class="btn btn-secondary btn-block mt-3">
                            <span>&#128203;</span> Copy Text Summary
                        </button>

                        <div id="fullDetailsContainer" class="hidden mt-3">
                            <textarea id="fullDetailsText" readonly class="form-control form-textarea form-control-mono text-xs" style="height: 150px;"></textarea>
                        </div>
                    </div>
                </details>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideShareModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" role="status" aria-live="polite">
        <div id="toast" class="toast"></div>
    </div>

    <script>
        // ==================== THEME MANAGEMENT ====================
        function initTheme() {
            const savedTheme = localStorage.getItem('stackbill-theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('stackbill-theme', newTheme);
        }

        // Initialize theme immediately
        initTheme();

        // ==================== UTILITY FUNCTIONS ====================
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== CONFIGURATION ====================

        // Server purpose options for Environment Check
        const SERVER_PURPOSES = [
            { value: 'k8s-master', label: 'Kubernetes Master', icon: '&#9784;' },
            { value: 'k8s-worker', label: 'Kubernetes Worker', icon: '&#9784;' },
            { value: 'mysql-primary', label: 'MySQL Primary', icon: '&#128024;' },
            { value: 'mysql-secondary', label: 'MySQL Secondary', icon: '&#128024;' },
            { value: 'mongodb-primary', label: 'MongoDB Primary', icon: '&#127811;' },
            { value: 'mongodb-secondary', label: 'MongoDB Secondary', icon: '&#127811;' },
            { value: 'mongodb-arbiter', label: 'MongoDB Arbiter', icon: '&#127811;' },
            { value: 'rabbitmq', label: 'RabbitMQ Server', icon: '&#128007;' },
            { value: 'nfs', label: 'NFS / Management Server', icon: '&#128193;' },
            { value: 'loadbalancer', label: 'Load Balancer', icon: '&#9878;' }
        ];

        // SSH Authentication types
        const SSH_AUTH_TYPES = [
            { value: 'password', label: 'Password', icon: '&#128273;' },
            { value: 'key', label: 'SSH Key', icon: '&#128272;' }
        ];

        // User types for SSH connection
        const SSH_USER_TYPES = [
            { value: 'root', label: 'Root User', description: 'Direct root access' },
            { value: 'sudo', label: 'Sudo User', description: 'Escalate to root with sudo' }
        ];

        // Deployment steps ordered according to StackBill documentation:
        // https://docs.stackbill.com/docs/deployment/getting-started
        const DEPLOYMENT_STEPS = [
            {
                id: 'env-check',
                number: 1,
                title: 'Environment',
                fullTitle: 'Environment Preparation',
                description: 'Verify network, firewall, and connectivity',
                icon: '&#127760;',
                type: 'check'
            },
            {
                id: 'kubernetes',
                number: 2,
                title: 'Kubernetes',
                fullTitle: 'Kubernetes Cluster',
                description: 'Setup master and worker nodes',
                icon: '&#9784;',
                type: 'deployment'
            },
            {
                id: 'rabbitmq',
                number: 3,
                title: 'RabbitMQ',
                fullTitle: 'RabbitMQ Message Broker',
                description: 'Install RabbitMQ server',
                icon: '&#128007;',
                type: 'deployment'
            },
            {
                id: 'mongodb',
                number: 4,
                title: 'MongoDB',
                fullTitle: 'MongoDB Database',
                description: 'Setup MongoDB replica set',
                icon: '&#127811;',
                type: 'deployment',
                hasMode: true,
                modes: ['single', 'cluster']
            },
            {
                id: 'mysql',
                number: 5,
                title: 'MySQL',
                fullTitle: 'MySQL Database',
                description: 'Install MySQL with replication',
                icon: '&#128024;',
                type: 'deployment',
                hasMode: true,
                modes: ['single', 'cluster']
            },
            {
                id: 'nfs',
                number: 6,
                title: 'NFS',
                fullTitle: 'NFS Storage Server',
                description: 'Setup NFS for shared storage',
                icon: '&#128193;',
                type: 'deployment',
                extraFields: ['disk_device', 'client_ip_range']
            },
            {
                id: 'loadbalancer',
                number: 7,
                title: 'Load Balancer',
                fullTitle: 'Load Balancer Setup',
                description: 'Install and configure HAProxy/Nginx with SSL',
                icon: '&#9878;',
                type: 'deployment',
                hasSSLConfig: true,
                hasLoadBalancerConfig: true
            },
            {
                id: 'kubectl',
                number: 8,
                title: 'Kubectl & Istio',
                fullTitle: 'Kubectl & Istio Setup',
                description: 'Install Kubernetes CLI and service mesh',
                icon: '&#9881;',
                type: 'deployment'
            },
            {
                id: 'helm',
                number: 9,
                title: 'Helm',
                fullTitle: 'Helm Package Manager',
                description: 'Install Helm for K8s deployments',
                icon: '&#9875;',
                type: 'deployment'
            },
            {
                id: 'ssl',
                number: 10,
                title: 'SSL (Optional)',
                fullTitle: 'SSL Certificates (Additional)',
                description: 'Update/regenerate SSL certificates (optional)',
                icon: '&#128274;',
                type: 'config',
                hasSSLConfig: true,
                isOptional: true
            },
            {
                id: 'stackbill',
                number: 11,
                title: 'StackBill',
                fullTitle: 'StackBill Application',
                description: 'Deploy StackBill application',
                icon: '&#127919;',
                type: 'deployment'
            }
        ];

        // ==================== STATE ====================
        const state = {
            sessionId: null,           // Database session ID
            sessionName: 'Deployment Session',
            currentStep: 0,
            activePanel: null,
            completedSteps: new Set(),
            failedSteps: new Set(),    // Steps that failed (persisted)
            stepStatuses: {},          // Step status: 'completed' or 'failed'
            stepTaskResults: {},       // Task-level results for each step (persisted)
            stepData: {},
            credentials: {},
            servers: {},
            modes: {
                mysql: 'single',
                mongodb: 'single'
            },
            sslConfig: {
                type: 'letsencrypt', // 'letsencrypt' or 'upload'
                domain: '',
                certificate: '',
                privateKey: ''
            },
            nfsConfig: {
                diskDevice: '/dev/sdb',
                clientIpRange: '*'
            },
            loadBalancerConfig: {
                type: 'haproxy',    // 'haproxy' or 'nginx'
                backendPort: '30080' // NodePort on K8s
            },
            automationMode: 'manual',  // 'manual' (step-by-step) or 'auto' (full automation)
            generatedFiles: []         // Files to auto-download
        };

        // Global settings (loaded from /api/settings)
        let globalSettings = {
            autoCleanup: false
        };

        // Get session ID from URL parameter
        function getSessionIdFromUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('session');
        }

        // Load state from database or redirect to sessions page
        async function loadState() {
            // Priority: URL parameter > localStorage
            const urlSessionId = getSessionIdFromUrl();
            const savedSessionId = urlSessionId || localStorage.getItem('stackbill_session_id');

            if (savedSessionId) {
                try {
                    const response = await fetch(`/api/sessions/${savedSessionId}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.session) {
                            const session = data.session;
                            state.sessionId = session.id;
                            state.sessionName = session.name;
                            state.completedSteps = new Set(session.completedSteps || []);
                            state.failedSteps = new Set(session.failedSteps || []);
                            state.stepStatuses = session.stepStatuses || {};
                            state.stepTaskResults = session.stepTaskResults || {};
                            state.credentials = session.credentials || {};
                            state.stepData = session.stepData || {};
                            state.currentStep = session.current_step || 0;
                            state.modes = session.modes || { mysql: 'single', mongodb: 'single' };
                            state.sslConfig = session.sslConfig || { type: 'letsencrypt', domain: '', certificate: '', privateKey: '' };
                            state.nfsConfig = session.nfsConfig || { diskDevice: '', clientIpRange: '*' };
                            state.loadBalancerConfig = session.loadBalancerConfig || { type: 'haproxy', backendPort: '30080' };
                            state.servers = session.servers || {};
                            state.automationMode = session.automation_mode || 'manual';

                            // Sync localStorage with current session
                            localStorage.setItem('stackbill_session_id', session.id);

                            // Update URL if needed (without reload)
                            if (!urlSessionId) {
                                const newUrl = `${window.location.pathname}?session=${session.id}`;
                                window.history.replaceState({}, '', newUrl);
                            }

                            console.log('Session loaded from database:', state.sessionId);
                            return;
                        }
                    }
                } catch (e) {
                    console.error('Failed to load session from database:', e);
                }
            }

            // No valid session found - redirect to sessions page
            window.location.href = '/sessions.html';
        }

        // Create a new session in database
        async function createNewSession(name = 'Deployment Session') {
            try {
                const response = await fetch('/api/sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const data = await response.json();
                if (data.success) {
                    state.sessionId = data.session.id;
                    state.sessionName = data.session.name;
                    localStorage.setItem('stackbill_session_id', state.sessionId);
                    console.log('New session created:', state.sessionId);
                }
            } catch (e) {
                console.error('Failed to create session:', e);
            }
        }

        // Save state to database
        async function saveState() {
            if (!state.sessionId) return;

            try {
                // Update session with current step and automation mode
                await fetch(`/api/sessions/${state.sessionId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        current_step: state.currentStep,
                        automation_mode: state.automationMode
                    })
                });

                // Save SSL config
                if (state.sslConfig) {
                    await fetch(`/api/sessions/${state.sessionId}/ssl-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: state.sslConfig })
                    });
                }

                // Save NFS config
                if (state.nfsConfig) {
                    await fetch(`/api/sessions/${state.sessionId}/nfs-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: state.nfsConfig })
                    });
                }

                // Save Load Balancer config
                if (state.loadBalancerConfig) {
                    await fetch(`/api/sessions/${state.sessionId}/lb-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: state.loadBalancerConfig })
                    });
                }
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // Save servers for a step to database
        async function saveServersToDb(stepId) {
            if (!state.sessionId || !state.servers[stepId]) return;

            try {
                await fetch(`/api/sessions/${state.sessionId}/servers/${stepId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ servers: state.servers[stepId] })
                });
            } catch (e) {
                console.error('Failed to save servers:', e);
            }
        }

        // Save credentials to database
        async function saveCredentialsToDb(service, credentials) {
            if (!state.sessionId) return;

            try {
                await fetch(`/api/sessions/${state.sessionId}/credentials/${service}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ credentials })
                });
            } catch (e) {
                console.error('Failed to save credentials:', e);
            }
        }

        // Mark step complete or failed in database (persists across restarts)
        async function markStepCompleteInDb(stepId, stepData = {}, status = 'completed', taskResults = null) {
            if (!state.sessionId) return;

            try {
                await fetch(`/api/sessions/${state.sessionId}/steps/${stepId}/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stepData, status, taskResults })
                });
            } catch (e) {
                console.error('Failed to mark step status:', e);
            }
        }

        // Get saved step status from database
        async function getStepStatusFromDb(stepId) {
            if (!state.sessionId) return null;

            try {
                const response = await fetch(`/api/sessions/${state.sessionId}/steps/${stepId}/status`);
                const data = await response.json();
                return data.status;
            } catch (e) {
                console.error('Failed to get step status:', e);
                return null;
            }
        }

        // Remove server from database
        async function removeServerFromDb(serverId) {
            if (!state.sessionId) return;

            try {
                await fetch(`/api/sessions/${state.sessionId}/servers/${serverId}`, {
                    method: 'DELETE'
                });
            } catch (e) {
                console.error('Failed to remove server:', e);
            }
        }

        // Save generated file to database
        async function saveGeneratedFile(stepId, filename, content, mimeType = 'text/plain') {
            if (!state.sessionId) return;

            try {
                const response = await fetch(`/api/sessions/${state.sessionId}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stepId, filename, content, mimeType })
                });
                const data = await response.json();
                return data.fileId;
            } catch (e) {
                console.error('Failed to save file:', e);
                return null;
            }
        }

        // Cleanup session (remove sensitive data)
        async function cleanupSessionData() {
            if (!state.sessionId) return;

            try {
                await fetch(`/api/sessions/${state.sessionId}/cleanup`, {
                    method: 'POST'
                });
                console.log('Session cleaned up');
            } catch (e) {
                console.error('Failed to cleanup session:', e);
            }
        }

        // ==================== HELPER FUNCTIONS ====================
        // Get servers from env-check by purpose prefix
        function getEnvCheckServersByPurpose(purposePrefix) {
            const envCheckServers = state.servers['env-check'] || [];
            return envCheckServers.filter(s => s.purpose && s.purpose.startsWith(purposePrefix));
        }

        // Auto-detect deployment mode based on env-check selections
        function detectDeploymentMode(stepId) {
            if (stepId === 'mysql') {
                const mysqlServers = getEnvCheckServersByPurpose('mysql-');
                const hasSecondary = mysqlServers.some(s => s.purpose === 'mysql-secondary');
                return hasSecondary ? 'cluster' : 'single';
            } else if (stepId === 'mongodb') {
                const mongoServers = getEnvCheckServersByPurpose('mongodb-');
                // If more than 1 mongodb server, it's cluster mode
                return mongoServers.length > 1 ? 'cluster' : 'single';
            } else if (stepId === 'kubernetes') {
                const k8sServers = getEnvCheckServersByPurpose('k8s-');
                const hasWorker = k8sServers.some(s => s.purpose === 'k8s-worker');
                return hasWorker ? 'cluster' : 'single';
            }
            return 'single';
        }

        // Pre-populate servers for a step from env-check
        function populateServersFromEnvCheck(stepId) {
            const envCheckServers = state.servers['env-check'] || [];
            let relevantServers = [];

            if (stepId === 'mysql') {
                relevantServers = envCheckServers.filter(s => s.purpose?.startsWith('mysql-'));
            } else if (stepId === 'mongodb') {
                relevantServers = envCheckServers.filter(s => s.purpose?.startsWith('mongodb-'));
            } else if (stepId === 'kubernetes') {
                relevantServers = envCheckServers.filter(s => s.purpose?.startsWith('k8s-'));
            } else if (stepId === 'rabbitmq') {
                relevantServers = envCheckServers.filter(s => s.purpose === 'rabbitmq');
            } else if (stepId === 'nfs' || stepId === 'kubectl' || stepId === 'helm' || stepId === 'ssl' || stepId === 'stackbill') {
                relevantServers = envCheckServers.filter(s => s.purpose === 'nfs');
            }

            if (relevantServers.length > 0 && (!state.servers[stepId] || state.servers[stepId].length === 0)) {
                state.servers[stepId] = relevantServers.map(s => ({
                    id: Date.now() + Math.random(),
                    hostname: s.hostname,
                    ssh_port: s.ssh_port,
                    ssh_auth_type: s.ssh_auth_type || 'password',
                    ssh_user: s.ssh_user || 'root',
                    ssh_user_type: s.ssh_user_type || 'root',
                    password: s.password,
                    ssh_key: s.ssh_key || '',
                    sudo_password: s.sudo_password || '',
                    role: mapPurposeToRole(s.purpose),
                    name: s.name
                }));
            }
        }

        // Map env-check purpose to step role
        function mapPurposeToRole(purpose) {
            const mapping = {
                'k8s-master': 'master',
                'k8s-worker': 'worker',
                'mysql-primary': 'primary',
                'mysql-secondary': 'secondary',
                'mongodb-primary': 'primary',
                'mongodb-secondary': 'secondary',
                'mongodb-arbiter': 'arbiter'
            };
            return mapping[purpose] || 'primary';
        }

        // ==================== INITIALIZATION ====================
        async function init() {
            // Show loading state
            document.getElementById('stepsGrid').innerHTML = '<div style="text-align: center; padding: 40px; color: var(--color-text-muted);">Loading session...</div>';

            // Load global settings first
            await loadGlobalSettings();

            await loadState();
            updateSessionDisplay();  // Update header with session name
            renderProgressSteps();
            renderStepCards();
            renderSummary();

            // Auto-open first incomplete step if in auto mode
            const firstIncomplete = DEPLOYMENT_STEPS.find(step => !state.completedSteps.has(step.id));
            if (firstIncomplete && state.automationMode === 'auto' && state.completedSteps.size > 0) {
                // Auto-continue deployment
                openStepPanel(firstIncomplete.id);
            }
        }

        // ==================== RENDERING ====================
        function renderProgressSteps() {
            const container = document.getElementById('progressSteps');
            container.innerHTML = DEPLOYMENT_STEPS.map((step, index) => {
                const isCompleted = state.completedSteps.has(step.id);
                const isActive = state.activePanel === step.id;
                const statusClass = isCompleted ? 'completed' : isActive ? 'active' : 'locked';

                const connector = index < DEPLOYMENT_STEPS.length - 1
                    ? `<div class="step-connector ${isCompleted ? 'completed' : ''}"></div>`
                    : '';

                return `
                    <div class="progress-step">
                        <div class="step-circle ${statusClass}">
                            ${isCompleted ? '&#10003;' : step.number}
                        </div>
                        <span class="step-label">${step.title}</span>
                        ${connector}
                    </div>
                `;
            }).join('');
        }

        function renderStepCards() {
            const container = document.getElementById('stepsGrid');
            container.innerHTML = DEPLOYMENT_STEPS.map((step, index) => {
                const isCompleted = state.completedSteps.has(step.id);
                const isActive = state.activePanel === step.id;
                const isLocked = !isCompleted && !canAccessStep(index);

                let statusClass = 'pending';
                let statusText = 'Pending';
                let statusIcon = '&#9711;';

                if (isCompleted) {
                    statusClass = 'completed';
                    statusText = 'Completed';
                    statusIcon = '&#10003;';
                } else if (isActive) {
                    statusClass = 'active';
                    statusText = 'In Progress';
                    statusIcon = '&#9654;';
                } else if (isLocked) {
                    statusClass = 'locked';
                    statusText = 'Locked';
                    statusIcon = '&#128274;';
                }

                const cardClass = `step-card ${isCompleted ? 'completed' : ''} ${isActive ? 'active' : ''} ${isLocked ? 'locked' : ''}`;

                return `
                    <div class="${cardClass}" onclick="openStep('${step.id}', ${index})" data-step="${step.id}">
                        ${isLocked ? '<span class="lock-icon">&#128274;</span>' : ''}
                        <div class="step-card-header">
                            <div class="step-icon">${step.icon}</div>
                            <span class="step-number">Step ${step.number}</span>
                        </div>
                        <div class="step-title">${step.title}</div>
                        <div class="step-description">${step.description}</div>
                        <div class="step-status ${statusClass}">
                            <span>${statusIcon}</span>
                            ${statusText}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderSummary() {
            const container = document.getElementById('summaryContent');

            // Steps section
            const stepsHtml = DEPLOYMENT_STEPS.map(step => {
                const isCompleted = state.completedSteps.has(step.id);
                const isActive = state.activePanel === step.id;
                const iconClass = isCompleted ? 'completed' : isActive ? 'active' : 'pending';
                const icon = isCompleted ? '&#10003;' : isActive ? '&#9654;' : step.number;

                const details = state.stepData[step.id]
                    ? formatStepDetails(step.id, state.stepData[step.id])
                    : 'Not configured';

                return `
                    <div class="summary-step">
                        <div class="summary-step-icon ${iconClass}">${icon}</div>
                        <div class="summary-step-info">
                            <div class="summary-step-name">${step.fullTitle}</div>
                            <div class="summary-step-details">${details}</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Credentials section
            const credServices = ['mysql', 'mongodb', 'rabbitmq'];
            const credsHtml = credServices.map(service => {
                const creds = state.credentials[service];
                if (!creds) return `
                    <div class="summary-cred-item">
                        <div class="summary-cred-service">${service.toUpperCase()}</div>
                        <div class="summary-cred-row">
                            <span class="summary-cred-label">Status</span>
                            <span class="summary-cred-value">Pending</span>
                        </div>
                    </div>
                `;

                return `
                    <div class="summary-cred-item">
                        <div class="summary-cred-service">${service.toUpperCase()}</div>
                        ${creds.username ? `
                            <div class="summary-cred-row">
                                <span class="summary-cred-label">Username</span>
                                <span class="summary-cred-value">${creds.username}</span>
                            </div>
                        ` : ''}
                        ${creds.password ? `
                            <div class="summary-cred-row">
                                <span class="summary-cred-label">Password</span>
                                <span class="summary-cred-value">${creds.password}</span>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // Session info
            const sessionId = state.sessionId ? state.sessionId.substring(0, 8) + '...' : 'Local';

            const completedCount = state.completedSteps.size;
            const totalSteps = DEPLOYMENT_STEPS.length;
            const progressPct = Math.round((completedCount / totalSteps) * 100);

            container.innerHTML = `
                <div class="summary-section summary-session-info">
                    <div class="summary-section-title">Session</div>
                    <div class="summary-session-details">
                        <div><strong>ID:</strong> ${sessionId}</div>
                        <div><strong>Name:</strong> ${state.sessionName || 'Deployment Session'}</div>
                        <div><strong>Progress:</strong> ${completedCount}/${totalSteps} steps (${progressPct}%)</div>
                    </div>
                    <div class="summary-mode-toggle">
                        <div class="summary-mode-title">Deployment Mode</div>
                        <div class="summary-mode-options">
                            <label class="summary-mode-option ${state.automationMode === 'manual' ? 'active' : ''}">
                                <input type="radio" name="automationMode" value="manual" ${state.automationMode === 'manual' ? 'checked' : ''} onchange="setAutomationMode('manual')">
                                <span>Step-by-Step</span>
                            </label>
                            <label class="summary-mode-option ${state.automationMode === 'auto' ? 'active' : ''}">
                                <input type="radio" name="automationMode" value="auto" ${state.automationMode === 'auto' ? 'checked' : ''} onchange="setAutomationMode('auto')">
                                <span>Auto-Complete</span>
                            </label>
                        </div>
                        <div class="summary-mode-hint">
                            ${state.automationMode === 'auto' ? 'All remaining steps will run automatically.' : 'Each step requires manual confirmation.'}
                        </div>
                    </div>
                </div>
                <div class="summary-section">
                    <div class="summary-section-title">Deployment Progress</div>
                    ${stepsHtml}
                </div>
                <div class="summary-section">
                    <div class="summary-section-title">Captured Credentials</div>
                    <div class="summary-credentials">
                        ${credsHtml}
                    </div>
                </div>
                <div class="summary-section summary-actions">
                    <div class="summary-section-title">Session Actions</div>
                    <div class="summary-action-btns">
                        <button onclick="shareSession()" class="btn btn-success btn-sm btn-block">
                            <span>&#128279;</span> Share Session
                        </button>
                        <button onclick="startNewSession()" class="btn btn-primary btn-sm btn-block">
                            Start New Session
                        </button>
                        <button onclick="deleteCurrentSession()" class="btn btn-danger-solid btn-sm btn-block">
                            Delete Current Session
                        </button>
                    </div>
                </div>
            `;
        }

        function formatStepDetails(stepId, data) {
            if (!data) return 'Not configured';
            if (data.servers && data.servers.length > 0) {
                // For env-check, show purposes
                if (stepId === 'env-check') {
                    const purposeCounts = {};
                    data.servers.forEach(s => {
                        const label = SERVER_PURPOSES.find(p => p.value === s.purpose)?.label || 'VM';
                        purposeCounts[label] = (purposeCounts[label] || 0) + 1;
                    });
                    const summary = Object.entries(purposeCounts)
                        .map(([label, count]) => `${count} ${label}`)
                        .join(', ');
                    return summary || `${data.servers.length} VM(s) checked`;
                }
                return `${data.servers.length} server(s) configured`;
            }
            return 'Configured';
        }

        // ==================== STEP MANAGEMENT ====================
        function canAccessStep(index) {
            if (index === 0) return true;
            // Check if all previous steps are completed
            for (let i = 0; i < index; i++) {
                if (!state.completedSteps.has(DEPLOYMENT_STEPS[i].id)) {
                    return false;
                }
            }
            return true;
        }

        function openStep(stepId, index) {
            if (!canAccessStep(index)) {
                alert('Please complete the previous steps first.');
                return;
            }

            state.activePanel = stepId;
            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);

            // Auto-detect mode and populate servers from env-check (for steps after env-check)
            if (stepId !== 'env-check' && state.completedSteps.has('env-check')) {
                // Auto-detect deployment mode based on env-check selections
                const detectedMode = detectDeploymentMode(stepId);
                if (step.hasMode) {
                    state.modes[stepId] = detectedMode;
                }
                // Pre-populate servers from env-check
                populateServersFromEnvCheck(stepId);
            }

            document.getElementById('panelTitle').textContent = step.fullTitle;
            document.getElementById('panelContent').innerHTML = generateStepForm(step);
            document.getElementById('activePanel').classList.add('visible');

            // Initialize servers if not already populated
            if (!state.servers[stepId] || state.servers[stepId].length === 0) {
                state.servers[stepId] = [];
                addServerToStep(stepId);
            } else {
                renderServers(stepId);
            }

            renderProgressSteps();
            renderStepCards();

            // Scroll to panel
            document.getElementById('activePanel').scrollIntoView({ behavior: 'smooth' });
        }

        function closePanel() {
            state.activePanel = null;
            document.getElementById('activePanel').classList.remove('visible');
            renderProgressSteps();
            renderStepCards();
        }

        function generateStepForm(step) {
            let formHtml = '';

            // Mode display for MySQL and MongoDB (auto-detected from env-check)
            if (step.hasMode) {
                const currentMode = state.modes[step.id] || 'single';
                const modeLabel = currentMode === 'cluster' ? 'Cluster / Replication' : 'Standalone';
                const modeDescription = currentMode === 'cluster'
                    ? 'Multiple servers detected from Environment Check'
                    : 'Single server detected from Environment Check';

                formHtml += `
                    <div class="form-section" style="background: rgba(16, 185, 129, 0.05); padding: 16px; border-radius: 10px; border: 1px solid rgba(16, 185, 129, 0.2);">
                        <div class="form-section-title" style="color: var(--success);">&#9881; Deployment Mode: ${modeLabel}</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin: 0;">
                            ${modeDescription}. Servers pre-filled from your Environment Check.
                        </p>
                    </div>
                `;
            }

            // Servers section - read-only for deployment steps (pre-filled from env-check)
            formHtml += `
                <div class="form-section">
                    <div class="form-section-title">&#128421; Target Server(s)</div>
                    <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 12px;">
                        Pre-filled from your Environment Check configuration.
                    </p>
                    <div class="servers-container" id="servers-${step.id}">
                        <!-- Servers rendered here -->
                    </div>
                    <button type="button" class="add-server-btn" onclick="addServerToStep('${step.id}')" id="add-btn-${step.id}" style="display: none;">
                        <span>+</span> Add Server
                    </button>
                </div>
            `;

            // Extra fields for NFS only
            if (step.id === 'nfs' && step.extraFields) {
                formHtml += `
                    <div class="form-section">
                        <div class="form-section-title">&#9881; NFS Storage Configuration</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                            Configure NFS storage. You can provide a disk for dedicated storage, or leave empty to use a directory in the root filesystem.
                        </p>
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Disk Device (Optional)</label>
                                <input type="text" class="form-input" id="disk_device" placeholder="e.g., /dev/sdb or leave empty" value="${state.nfsConfig?.diskDevice || ''}" onchange="updateNfsConfig('diskDevice', this.value)">
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Leave empty for directory-only mode. Provide raw disk (e.g., /dev/sdb) to format, or partition (e.g., /dev/sdb1) to mount directly.
                                </span>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Client IP Range</label>
                                <input type="text" class="form-input" id="client_ip_range" placeholder="*" value="${state.nfsConfig?.clientIpRange || '*'}" onchange="updateNfsConfig('clientIpRange', this.value)">
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Use * for all clients, or specify range (e.g., 192.168.1.0/24)
                                </span>
                            </div>
                        </div>
                        <div style="background: rgba(102, 126, 234, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.2); margin-top: 12px;">
                            <div style="font-size: 0.8rem; color: var(--color-text-secondary);">
                                <strong style="color: var(--primary);">What will happen:</strong>
                                <ul style="margin: 8px 0 0 16px; padding: 0;">
                                    <li><strong>If disk provided:</strong> Partition (if raw), format XFS, mount at /storage</li>
                                    <li><strong>If empty:</strong> Create /storage directory in root filesystem</li>
                                    <li>Create /storage/k8-data export directory</li>
                                    <li>Configure NFS exports for specified clients</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Load Balancer Configuration (includes SSL)
            if (step.hasLoadBalancerConfig) {
                const sslType = state.sslConfig.type || 'letsencrypt';
                const lbType = state.loadBalancerConfig?.type || 'haproxy';
                const backendPort = state.loadBalancerConfig?.backendPort || '30080';
                formHtml = `
                    <!-- Load Balancer Type Selection -->
                    <div class="form-section">
                        <div class="form-section-title">&#9878; Load Balancer Type</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                            Choose which load balancer software to install and configure.
                        </p>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="flex: 1; min-width: 200px; display: flex; align-items: flex-start; gap: 12px; cursor: pointer; padding: 16px; border-radius: 10px; border: 2px solid ${lbType === 'haproxy' ? 'var(--primary)' : 'var(--color-border)'}; background: ${lbType === 'haproxy' ? 'rgba(102, 126, 234, 0.05)' : 'var(--color-bg-elevated)'}; transition: all 0.2s;">
                                <input type="radio" name="lbType" value="haproxy" ${lbType === 'haproxy' ? 'checked' : ''} onchange="setLoadBalancerType('haproxy')" style="margin-top: 3px;">
                                <div>
                                    <div style="font-weight: 600; color: var(--color-text-primary); font-size: 0.95rem;">HAProxy (Recommended)</div>
                                    <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 4px;">High-performance TCP/HTTP load balancer with built-in stats dashboard</div>
                                </div>
                            </label>
                            <label style="flex: 1; min-width: 200px; display: flex; align-items: flex-start; gap: 12px; cursor: pointer; padding: 16px; border-radius: 10px; border: 2px solid ${lbType === 'nginx' ? 'var(--primary)' : 'var(--color-border)'}; background: ${lbType === 'nginx' ? 'rgba(102, 126, 234, 0.05)' : 'var(--color-bg-elevated)'}; transition: all 0.2s;">
                                <input type="radio" name="lbType" value="nginx" ${lbType === 'nginx' ? 'checked' : ''} onchange="setLoadBalancerType('nginx')" style="margin-top: 3px;">
                                <div>
                                    <div style="font-weight: 600; color: var(--color-text-primary); font-size: 0.95rem;">Nginx</div>
                                    <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 4px;">Versatile web server and reverse proxy</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Backend Port Configuration -->
                    <div class="form-section">
                        <div class="form-section-title">&#9881; Backend Configuration</div>
                        <div class="form-group">
                            <label class="form-label">Kubernetes Ingress NodePort *</label>
                            <input type="text" class="form-input" id="lb_backend_port"
                                   placeholder="30080"
                                   value="${backendPort}"
                                   onchange="updateLoadBalancerConfig('backendPort', this.value)"
                                   style="max-width: 200px;">
                            <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                The NodePort where Kubernetes Ingress is exposed (default: 30080)
                            </span>
                        </div>
                    </div>

                    <!-- SSL Certificate Configuration -->
                    <div class="form-section">
                        <div class="form-section-title">&#128274; SSL Certificate Configuration</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                            Configure SSL certificates for HTTPS termination on the load balancer.
                        </p>

                        <!-- SSL Type Radio Buttons -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 0.85rem; font-weight: 600; color: var(--color-text-secondary); margin-bottom: 12px;">Certificate Type</div>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer; padding: 12px; border-radius: 8px; border: 2px solid ${sslType === 'letsencrypt' ? 'var(--primary)' : 'var(--color-border)'}; background: ${sslType === 'letsencrypt' ? 'rgba(102, 126, 234, 0.05)' : 'white'}; transition: all 0.2s;">
                                    <input type="radio" name="sslType" value="letsencrypt" ${sslType === 'letsencrypt' ? 'checked' : ''} onchange="setSSLType('letsencrypt')" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--color-text-primary);">&#127919; Let's Encrypt (Recommended)</div>
                                        <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px;">Free trusted certificate with auto-renewal (requires domain validation)</div>
                                    </div>
                                </label>
                                <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer; padding: 12px; border-radius: 8px; border: 2px solid ${sslType === 'upload' ? 'var(--primary)' : 'var(--color-border)'}; background: ${sslType === 'upload' ? 'rgba(102, 126, 234, 0.05)' : 'white'}; transition: all 0.2s;">
                                    <input type="radio" name="sslType" value="upload" ${sslType === 'upload' ? 'checked' : ''} onchange="setSSLType('upload')" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--color-text-primary);">&#128194; Upload Custom Certificate</div>
                                        <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px;">Use your own certificate from a Certificate Authority</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <!-- Domain Name (required for all types) -->
                        <div class="form-group" style="margin-bottom: 16px;">
                            <label class="form-label">Domain Name *</label>
                            <input type="text" class="form-input" id="ssl_domain"
                                   placeholder="e.g., stackbill.example.com"
                                   value="${state.sslConfig.domain || ''}"
                                   onchange="updateSSLConfig('domain', this.value)">
                            <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                The domain name that will be used for your StackBill deployment
                            </span>
                        </div>

                        <!-- Let's Encrypt Notice -->
                        <div id="ssl-letsencrypt-info" style="display: ${sslType === 'letsencrypt' ? 'block' : 'none'};">
                            <div style="background: rgba(16, 185, 129, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);">
                                <p style="color: var(--color-text-secondary); font-size: 0.85rem; margin: 0;">
                                    <strong style="color: var(--success);">&#9989; Requirements:</strong>
                                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                                        <li>Domain must point to the load balancer's public IP</li>
                                        <li>Port 80 must be accessible for HTTP validation</li>
                                        <li>Certificate will auto-renew every 90 days</li>
                                    </ul>
                                </p>
                            </div>
                        </div>

                        <!-- Upload Certificate Form -->
                        <div id="ssl-upload-form" style="display: ${sslType === 'upload' ? 'block' : 'none'};">
                            <div class="form-group">
                                <label class="form-label">Full Chain Certificate (fullchain.pem) *</label>
                                <textarea class="form-input" id="ssl_certificate" rows="6"
                                          placeholder="-----BEGIN CERTIFICATE-----&#10;...certificate content...&#10;-----END CERTIFICATE-----"
                                          onchange="updateSSLConfig('certificate', this.value)"
                                          style="font-family: monospace; font-size: 0.85rem;">${state.sslConfig.certificate || ''}</textarea>
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Paste your full chain SSL certificate in PEM format (including intermediate certificates)
                                </span>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Private Key (privkey.pem) *</label>
                                <textarea class="form-input" id="ssl_private_key" rows="6"
                                          placeholder="-----BEGIN PRIVATE KEY-----&#10;...key content...&#10;-----END PRIVATE KEY-----"
                                          onchange="updateSSLConfig('privateKey', this.value)"
                                          style="font-family: monospace; font-size: 0.85rem;">${state.sslConfig.privateKey || ''}</textarea>
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Paste your private key in PEM format (keep this secure!)
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Target Server -->
                    <div class="form-section">
                        <div class="form-section-title">&#128421; Target Server</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 12px;">
                            Load balancer will be installed on the following server(s).
                        </p>
                        <div class="servers-container" id="servers-${step.id}">
                            <!-- Servers rendered here -->
                        </div>
                    </div>
                `;
            }
            // SSL Configuration only (for the optional SSL step)
            else if (step.hasSSLConfig) {
                const sslType = state.sslConfig.type || 'letsencrypt';
                formHtml = `
                    <div class="form-section" style="background: rgba(102, 126, 234, 0.05); padding: 16px; border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.2); margin-bottom: 20px;">
                        <p style="color: var(--color-text-secondary); font-size: 0.85rem; margin: 0;">
                            <strong style="color: var(--primary);">&#9432; Note:</strong> SSL was already configured during Load Balancer setup.
                            Use this step only if you need to update or regenerate certificates.
                        </p>
                    </div>
                    <div class="form-section">
                        <div class="form-section-title">&#128274; Update SSL Certificate</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                            Update or regenerate SSL certificates for your Load Balancer.
                        </p>

                        <!-- SSL Type Radio Buttons -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 0.85rem; font-weight: 600; color: var(--color-text-secondary); margin-bottom: 12px;">Certificate Type</div>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer; padding: 12px; border-radius: 8px; border: 2px solid ${sslType === 'letsencrypt' ? 'var(--primary)' : 'var(--color-border)'}; background: ${sslType === 'letsencrypt' ? 'rgba(102, 126, 234, 0.05)' : 'white'}; transition: all 0.2s;">
                                    <input type="radio" name="sslType" value="letsencrypt" ${sslType === 'letsencrypt' ? 'checked' : ''} onchange="setSSLType('letsencrypt')" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--color-text-primary);">&#127919; Let's Encrypt (Recommended)</div>
                                        <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px;">Free trusted certificate with auto-renewal (requires domain validation)</div>
                                    </div>
                                </label>
                                <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer; padding: 12px; border-radius: 8px; border: 2px solid ${sslType === 'upload' ? 'var(--primary)' : 'var(--color-border)'}; background: ${sslType === 'upload' ? 'rgba(102, 126, 234, 0.05)' : 'white'}; transition: all 0.2s;">
                                    <input type="radio" name="sslType" value="upload" ${sslType === 'upload' ? 'checked' : ''} onchange="setSSLType('upload')" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: var(--color-text-primary);">&#128194; Upload Custom Certificate</div>
                                        <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px;">Use your own certificate from a Certificate Authority</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <!-- Domain Name -->
                        <div class="form-group" style="margin-bottom: 16px;">
                            <label class="form-label">Domain Name *</label>
                            <input type="text" class="form-input" id="ssl_domain"
                                   placeholder="e.g., stackbill.example.com"
                                   value="${state.sslConfig.domain || ''}"
                                   onchange="updateSSLConfig('domain', this.value)">
                        </div>

                        <!-- Let's Encrypt Notice -->
                        <div id="ssl-letsencrypt-info" style="display: ${sslType === 'letsencrypt' ? 'block' : 'none'};">
                            <div style="background: rgba(16, 185, 129, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2); margin-bottom: 16px;">
                                <p style="color: var(--color-text-secondary); font-size: 0.85rem; margin: 0;">
                                    <strong style="color: var(--success);">&#9989; Requirements:</strong>
                                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                                        <li>Domain must point to the load balancer's public IP</li>
                                        <li>Port 80 must be accessible for HTTP validation</li>
                                        <li>Certificate will auto-renew every 90 days</li>
                                    </ul>
                                </p>
                            </div>
                        </div>

                        <!-- Upload Certificate Form -->
                        <div id="ssl-upload-form" style="display: ${sslType === 'upload' ? 'block' : 'none'};">
                            <div class="form-group">
                                <label class="form-label">Full Chain Certificate (fullchain.pem) *</label>
                                <textarea class="form-input" id="ssl_certificate" rows="6"
                                          placeholder="-----BEGIN CERTIFICATE-----&#10;...certificate content...&#10;-----END CERTIFICATE-----"
                                          onchange="updateSSLConfig('certificate', this.value)"
                                          style="font-family: monospace; font-size: 0.85rem;">${state.sslConfig.certificate || ''}</textarea>
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Paste your full chain SSL certificate in PEM format (including intermediate certificates)
                                </span>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Private Key (privkey.pem) *</label>
                                <textarea class="form-input" id="ssl_private_key" rows="6"
                                          placeholder="-----BEGIN PRIVATE KEY-----&#10;...key content...&#10;-----END PRIVATE KEY-----"
                                          onchange="updateSSLConfig('privateKey', this.value)"
                                          style="font-family: monospace; font-size: 0.85rem;">${state.sslConfig.privateKey || ''}</textarea>
                                <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                    Paste your private key in PEM format (keep this secure!)
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Target Server (Load Balancer) -->
                    <div class="form-section">
                        <div class="form-section-title">&#9878; Target Server (Load Balancer)</div>
                        <div class="servers-container" id="servers-${step.id}">
                            <!-- Servers rendered here -->
                        </div>
                    </div>
                `;
            }

            // Environment check specific - with purpose selection
            if (step.type === 'check') {
                formHtml = `
                    <!-- Deployment Mode Selection -->
                    <div class="form-section" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(118, 75, 162, 0.08) 100%); padding: 20px; border-radius: 12px; border: 2px solid rgba(102, 126, 234, 0.2); margin-bottom: 20px;">
                        <div class="form-section-title" style="color: var(--color-primary-500); font-size: 1rem; margin-bottom: 12px;">&#9881; Deployment Mode</div>
                        <p style="color: var(--color-text-secondary); font-size: 0.85rem; margin-bottom: 16px;">
                            Choose how you want to proceed with the deployment after environment check.
                        </p>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label class="mode-card ${state.automationMode === 'manual' ? 'selected' : ''}">
                                <input type="radio" name="deploymentMode" value="manual" ${state.automationMode === 'manual' ? 'checked' : ''} onchange="setAutomationMode('manual')" style="margin-top: 3px;">
                                <div>
                                    <div class="mode-card-title">&#128221; Step-by-Step</div>
                                    <div class="mode-card-desc">Review and confirm each deployment step manually. Recommended for first-time setup.</div>
                                </div>
                            </label>
                            <label class="mode-card ${state.automationMode === 'auto' ? 'selected' : ''}">
                                <input type="radio" name="deploymentMode" value="auto" ${state.automationMode === 'auto' ? 'checked' : ''} onchange="setAutomationMode('auto')" style="margin-top: 3px;">
                                <div>
                                    <div class="mode-card-title">&#128640; Auto-Complete</div>
                                    <div class="mode-card-desc">Automatically proceed through all steps after environment check passes.</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Auto-Complete Configuration Section -->
                    <div id="auto-complete-config" style="display: ${state.automationMode === 'auto' ? 'block' : 'none'};">
                        <div class="form-section" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08) 0%, rgba(16, 185, 129, 0.03) 100%); padding: 20px; border-radius: 12px; border: 2px solid rgba(16, 185, 129, 0.3); margin-bottom: 20px;">
                            <div class="form-section-title" style="color: var(--success); font-size: 1rem; margin-bottom: 8px;">&#128640; Auto-Complete Configuration</div>
                            <p style="color: var(--color-text-secondary); font-size: 0.85rem; margin-bottom: 16px;">
                                Provide the following details upfront so deployment can proceed without interruption.
                            </p>

                            <!-- NFS Configuration -->
                            <div style="background: var(--color-bg-card); padding: 16px; border-radius: 10px; margin-bottom: 16px; border: 1px solid var(--color-border);">
                                <div style="font-weight: 600; color: var(--color-text-primary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                    <span>&#128193;</span> NFS Storage Configuration
                                </div>
                                <div class="form-row">
                                    <div class="form-group" style="margin-bottom: 8px;">
                                        <label class="form-label">Disk Device (Optional)</label>
                                        <input type="text" class="form-input" id="auto_nfs_disk"
                                               value="${state.nfsConfig.diskDevice || ''}"
                                               onchange="updateNfsConfig('diskDevice', this.value)"
                                               placeholder="e.g., /dev/sdb or /dev/sdb1 (leave empty for directory-only)">
                                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                            Leave empty to use directory-only mode (no disk formatting). If provided: raw disk will be partitioned, partition will be mounted.
                                        </span>
                                    </div>
                                    <div class="form-group" style="margin-bottom: 8px;">
                                        <label class="form-label">Client IP Range</label>
                                        <input type="text" class="form-input" id="auto_nfs_client_ip"
                                               value="${state.nfsConfig.clientIpRange || '*'}"
                                               onchange="updateNfsConfig('clientIpRange', this.value)"
                                               placeholder="*">
                                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                            Use * for all clients, or specify range (e.g., 192.168.1.0/24)
                                        </span>
                                    </div>
                                </div>
                            </div>

                            <!-- Load Balancer & SSL Configuration -->
                            <div style="background: var(--color-bg-card); padding: 16px; border-radius: 10px; border: 1px solid var(--color-border);">
                                <div style="font-weight: 600; color: var(--color-text-primary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                    <span>&#9878;</span> Load Balancer & SSL Configuration
                                </div>
                                <div class="form-group" style="margin-bottom: 12px;">
                                    <label class="form-label">Load Balancer Type</label>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 6px;">
                                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 14px; border-radius: 6px; border: 2px solid ${state.loadBalancerConfig?.type === 'haproxy' ? 'var(--primary)' : 'var(--color-border)'}; background: ${state.loadBalancerConfig?.type === 'haproxy' ? 'rgba(102, 126, 234, 0.1)' : 'var(--color-bg-elevated)'};">
                                            <input type="radio" name="autoLbType" value="haproxy" ${state.loadBalancerConfig?.type === 'haproxy' || !state.loadBalancerConfig?.type ? 'checked' : ''} onchange="updateLoadBalancerConfig('type', 'haproxy')">
                                            <span style="font-size: 0.85rem;">HAProxy</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 14px; border-radius: 6px; border: 2px solid ${state.loadBalancerConfig?.type === 'nginx' ? 'var(--primary)' : 'var(--color-border)'}; background: ${state.loadBalancerConfig?.type === 'nginx' ? 'rgba(102, 126, 234, 0.1)' : 'var(--color-bg-elevated)'};">
                                            <input type="radio" name="autoLbType" value="nginx" ${state.loadBalancerConfig?.type === 'nginx' ? 'checked' : ''} onchange="updateLoadBalancerConfig('type', 'nginx')">
                                            <span style="font-size: 0.85rem;">Nginx</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group" style="margin-bottom: 12px;">
                                    <label class="form-label">Domain Name *</label>
                                    <input type="text" class="form-input" id="auto_ssl_domain"
                                           value="${state.sslConfig.domain || ''}"
                                           onchange="updateSSLConfig('domain', this.value)"
                                           placeholder="e.g., stackbill.example.com">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem;">
                                        The domain name for your StackBill deployment
                                    </span>
                                </div>
                                <div class="form-group" style="margin-bottom: 12px;">
                                    <label class="form-label">SSL Certificate Type</label>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 6px;">
                                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 14px; border-radius: 6px; border: 2px solid ${state.sslConfig.type === 'letsencrypt' ? 'var(--primary)' : 'var(--color-border)'}; background: ${state.sslConfig.type === 'letsencrypt' ? 'rgba(102, 126, 234, 0.1)' : 'var(--color-bg-elevated)'};">
                                            <input type="radio" name="autoSslType" value="letsencrypt" ${state.sslConfig.type === 'letsencrypt' ? 'checked' : ''} onchange="setSSLType('letsencrypt')">
                                            <span style="font-size: 0.85rem;">Let's Encrypt (Recommended)</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 14px; border-radius: 6px; border: 2px solid ${state.sslConfig.type === 'upload' ? 'var(--primary)' : 'var(--color-border)'}; background: ${state.sslConfig.type === 'upload' ? 'rgba(102, 126, 234, 0.1)' : 'var(--color-bg-elevated)'};">
                                            <input type="radio" name="autoSslType" value="upload" ${state.sslConfig.type === 'upload' ? 'checked' : ''} onchange="setSSLType('upload')">
                                            <span style="font-size: 0.85rem;">Upload Certificate</span>
                                        </label>
                                    </div>
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem; display: block; margin-top: 6px;">
                                        ${state.sslConfig.type === 'upload' ? 'Upload your own fullchain.pem and privkey.pem' : 'Free trusted certificate with auto-renewal (requires domain pointed to LB and port 80 open)'}
                                    </span>
                                </div>
                                <!-- Certificate Upload Fields (shown when upload is selected) -->
                                <div id="auto-ssl-upload-fields" style="display: ${state.sslConfig.type === 'upload' ? 'block' : 'none'}; margin-top: 12px; padding: 12px; background: var(--color-gray-50); border-radius: 8px;">
                                    <div class="form-group" style="margin-bottom: 12px;">
                                        <label class="form-label">Full Chain Certificate (fullchain.pem) *</label>
                                        <textarea class="form-input" id="auto_ssl_fullchain" rows="4"
                                                  placeholder="-----BEGIN CERTIFICATE-----&#10;...certificate content...&#10;-----END CERTIFICATE-----"
                                                  onchange="updateSSLConfig('certificate', this.value)"
                                                  style="font-family: monospace; font-size: 0.8rem;">${state.sslConfig.certificate || ''}</textarea>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Private Key (privkey.pem) *</label>
                                        <textarea class="form-input" id="auto_ssl_privkey" rows="4"
                                                  placeholder="-----BEGIN PRIVATE KEY-----&#10;...key content...&#10;-----END PRIVATE KEY-----"
                                                  onchange="updateSSLConfig('privateKey', this.value)"
                                                  style="font-family: monospace; font-size: 0.8rem;">${state.sslConfig.privateKey || ''}</textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">&#127760; Add All Your Infrastructure VMs</div>
                        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                            Add all VMs that will be part of your StackBill deployment. Select the purpose for each VM to help identify them later.
                        </p>
                        <div class="servers-container" id="servers-${step.id}">
                            <!-- Servers rendered here -->
                        </div>
                        <button type="button" class="add-server-btn" onclick="addServerToStep('${step.id}')" id="add-btn-${step.id}">
                            <span>+</span> Add VM
                        </button>
                    </div>
                `;
            }

            // Submit button - different text for check vs deployment
            const buttonText = step.type === 'check'
                ? `<span>&#9989;</span> Run Environment Check`
                : `<span>&#128640;</span> Deploy ${step.title}`;

            const progressTitle = step.type === 'check' ? 'Environment Check Progress' : 'Deployment Progress';

            formHtml += `
                <button type="button" class="submit-btn" id="submit-${step.id}" onclick="executeStep('${step.id}')">
                    ${buttonText}
                </button>

                <div class="progress-section" id="progress-${step.id}">
                    <div class="progress-header">
                        <span class="progress-title">${progressTitle}</span>
                        <span class="progress-percentage" id="progress-pct-${step.id}">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-bar-${step.id}" style="width: 0%"></div>
                    </div>
                    <div class="task-list" id="task-list-${step.id}"></div>
                </div>

                <div class="credentials-section" id="creds-${step.id}">
                    <div class="credentials-title">&#128273; Generated Credentials</div>
                    <div id="creds-content-${step.id}"></div>
                </div>

                <div class="result-message" id="result-${step.id}"></div>
            `;

            return formHtml;
        }

        // ==================== SERVER MANAGEMENT ====================
        function addServerToStep(stepId) {
            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);
            const mode = state.modes[stepId] || 'single';

            if (!state.servers[stepId]) {
                state.servers[stepId] = [];
            }

            // For single mode (non-env-check), only allow 1 server
            if (stepId !== 'env-check' && mode === 'single' && state.servers[stepId].length >= 1) {
                return;
            }

            const serverIndex = state.servers[stepId].length;
            let defaultRole = 'primary';
            let defaultPurpose = '';

            // Environment check - set purpose based on order
            if (stepId === 'env-check') {
                const purposes = ['k8s-master', 'k8s-worker', 'mysql-primary', 'mongodb-primary', 'rabbitmq', 'nfs'];
                defaultPurpose = purposes[serverIndex] || 'nfs';
                defaultRole = defaultPurpose;
            } else if (step.hasMode && mode === 'cluster') {
                if (stepId === 'mysql') {
                    defaultRole = serverIndex === 0 ? 'primary' : 'secondary';
                } else if (stepId === 'mongodb') {
                    if (serverIndex === 0) defaultRole = 'primary';
                    else if (serverIndex === 1) defaultRole = 'secondary';
                    else defaultRole = 'arbiter';
                }
            } else if (stepId === 'kubernetes') {
                defaultRole = serverIndex === 0 ? 'master' : 'worker';
            }

            state.servers[stepId].push({
                id: Date.now(),
                hostname: '',
                ssh_port: 22,
                ssh_auth_type: 'password', // 'password' or 'key'
                ssh_user: 'root',          // 'root' or sudo username
                ssh_user_type: 'root',     // 'root' or 'sudo'
                password: '',              // Used when auth_type is 'password' OR sudo password when user_type is 'sudo'
                ssh_key: '',               // Used when auth_type is 'key'
                sudo_password: '',         // Password for sudo escalation (if different from SSH password)
                role: defaultRole,
                purpose: defaultPurpose,
                name: ''
            });

            renderServers(stepId);
        }

        async function removeServerFromStep(stepId, serverId) {
            // Find the server to get its database ID if it has one
            const server = state.servers[stepId]?.find(s => s.id === serverId);

            // Remove from local state
            state.servers[stepId] = state.servers[stepId].filter(s => s.id !== serverId);
            renderServers(stepId);

            // Remove from database (use the server's db ID if available)
            if (server && server.dbId) {
                await removeServerFromDb(server.dbId);
            } else {
                // If no dbId, save the entire updated servers list
                await saveServersToDb(stepId);
            }
        }

        // Track collapsed state for server cards
        const collapsedServerCards = new Set();

        // Toggle server card collapse/expand
        function toggleServerCard(serverId) {
            const card = document.getElementById(`server-card-${serverId}`);
            if (card) {
                card.classList.toggle('collapsed');
                // Track the collapsed state
                if (card.classList.contains('collapsed')) {
                    collapsedServerCards.add(serverId);
                } else {
                    collapsedServerCards.delete(serverId);
                }
            }
        }

        function renderServers(stepId) {
            const container = document.getElementById(`servers-${stepId}`);
            if (!container) return;

            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);
            const mode = state.modes[stepId] || 'single';
            const servers = state.servers[stepId] || [];

            // For deployment steps (not env-check), show READ-ONLY server cards
            const isReadOnly = stepId !== 'env-check';

            container.innerHTML = servers.map((server, index) => {
                // Get display label for purpose/role badge
                const badgeLabel = stepId === 'env-check'
                    ? (SERVER_PURPOSES.find(p => p.value === server.purpose)?.label || 'Not Selected')
                    : (server.role ? server.role.charAt(0).toUpperCase() + server.role.slice(1) : 'Server');

                // Get SSH auth and user type labels for display
                const authTypeLabel = server.ssh_auth_type === 'key' ? 'SSH Key' : 'Password';
                const userTypeLabel = server.ssh_user_type === 'sudo' ? `Sudo (${server.ssh_user || 'user'})` : 'Root';

                // READ-ONLY card for deployment steps
                if (isReadOnly) {
                    return `
                        <div class="server-card" style="background: rgba(102, 126, 234, 0.03);">
                            <div class="server-card-header">
                                <div class="server-role">
                                    <span class="server-role-badge">${badgeLabel}</span>
                                    ${server.name || server.hostname || `Server ${index + 1}`}
                                </div>
                            </div>
                            <div class="server-info-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 12px;">
                                <div class="server-info-item">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem; display: block;">Hostname / IP</span>
                                    <span style="color: var(--color-text-primary); font-weight: 500;">${server.hostname || '-'}</span>
                                </div>
                                <div class="server-info-item">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem; display: block;">SSH Port</span>
                                    <span style="color: var(--color-text-primary); font-weight: 500;">${server.ssh_port || 22}</span>
                                </div>
                                <div class="server-info-item">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem; display: block;">Auth Type</span>
                                    <span style="color: var(--color-text-primary); font-weight: 500;">${authTypeLabel}</span>
                                </div>
                                <div class="server-info-item">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem; display: block;">User</span>
                                    <span style="color: var(--color-text-primary); font-weight: 500;">${userTypeLabel}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // EDITABLE card for env-check
                let purposeOptions = '';
                if (stepId === 'env-check') {
                    // Get purposes already used by other servers (excluding this one)
                    const usedPurposes = servers
                        .filter(s => s.id !== server.id && s.purpose)
                        .map(s => s.purpose);

                    // Purposes that can have multiple selections (k8s master/worker)
                    const multiSelectPurposes = ['k8s-master', 'k8s-worker'];

                    // Filter available purposes: show if not used OR if it's a multi-select purpose OR if it's the current selection
                    const availablePurposes = SERVER_PURPOSES.filter(p =>
                        !usedPurposes.includes(p.value) ||
                        multiSelectPurposes.includes(p.value) ||
                        server.purpose === p.value
                    );

                    purposeOptions = `
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Server Purpose</label>
                                <select class="form-select" onchange="updateServerField('${stepId}', ${server.id}, 'purpose', this.value); updateServerField('${stepId}', ${server.id}, 'role', this.value);">
                                    <option value="" ${!server.purpose ? 'selected' : ''}>-- Select Purpose --</option>
                                    ${availablePurposes.map(p => `
                                        <option value="${p.value}" ${server.purpose === p.value ? 'selected' : ''}>${p.label}</option>
                                    `).join('')}
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Server Name (optional)</label>
                                <input type="text" class="form-input" placeholder="e.g., k8s-master-01"
                                       value="${server.name || ''}"
                                       onchange="updateServerField('${stepId}', ${server.id}, 'name', this.value)">
                            </div>
                        </div>
                    `;
                }

                // SSH Authentication type toggle
                const sshAuthType = server.ssh_auth_type || 'password';
                const sshUserType = server.ssh_user_type || 'root';

                // Build authentication fields based on type
                let authFields = '';
                if (sshAuthType === 'password') {
                    authFields = `
                        <div class="form-group">
                            <label class="form-label">SSH Password</label>
                            <div class="password-input-wrapper">
                                <input type="password" class="form-input" placeholder="Enter SSH password"
                                       id="ssh-password-${server.id}"
                                       value="${server.password || ''}"
                                       onchange="updateServerField('${stepId}', ${server.id}, 'password', this.value)">
                                <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('ssh-password-${server.id}', this)" title="Show/Hide password">
                                    <svg class="eye-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                        <circle cx="12" cy="12" r="3"></circle>
                                    </svg>
                                    <svg class="eye-off-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
                                        <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                        <line x1="1" y1="1" x2="23" y2="23"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    authFields = `
                        <div class="form-group">
                            <label class="form-label">SSH Private Key</label>
                            <textarea class="form-input" rows="4" placeholder="-----BEGIN OPENSSH PRIVATE KEY-----&#10;...&#10;-----END OPENSSH PRIVATE KEY-----"
                                      onchange="updateServerField('${stepId}', ${server.id}, 'ssh_key', this.value)">${server.ssh_key || ''}</textarea>
                            <span style="color: var(--color-text-muted); font-size: 0.75rem;">Paste your private key content</span>
                        </div>
                    `;
                }

                // Build sudo password field if sudo user type is selected
                let sudoPasswordField = '';
                if (sshUserType === 'sudo') {
                    sudoPasswordField = `
                        <div class="form-group">
                            <label class="form-label">Sudo Password</label>
                            <div class="password-input-wrapper">
                                <input type="password" class="form-input" placeholder="Password for sudo escalation"
                                       id="sudo-password-${server.id}"
                                       value="${server.sudo_password || ''}"
                                       onchange="updateServerField('${stepId}', ${server.id}, 'sudo_password', this.value)">
                                <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('sudo-password-${server.id}', this)" title="Show/Hide password">
                                    <svg class="eye-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                        <circle cx="12" cy="12" r="3"></circle>
                                    </svg>
                                    <svg class="eye-off-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
                                        <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                        <line x1="1" y1="1" x2="23" y2="23"></line>
                                    </svg>
                                </button>
                            </div>
                            <span style="color: var(--color-text-muted); font-size: 0.75rem;">Leave blank if same as SSH password</span>
                        </div>
                    `;
                }

                // Summary for collapsed state
                const serverSummary = server.hostname ? `${server.hostname}:${server.ssh_port || 22}` : 'Not configured';

                // Check if this card should be collapsed (preserve state during re-render)
                const isCollapsed = collapsedServerCards.has(server.id);

                return `
                    <div class="server-card ${isCollapsed ? 'collapsed' : ''}" id="server-card-${server.id}">
                        <div class="server-card-header" onclick="toggleServerCard(${server.id})">
                            <div class="server-role">
                                <span class="server-toggle-icon">&#9660;</span>
                                <span class="server-role-badge">${badgeLabel}</span>
                                <span>${server.name || `VM ${index + 1}`}</span>
                                <span style="color: var(--color-text-muted); font-weight: 400; font-size: 0.85rem; margin-left: 8px;">${serverSummary}</span>
                            </div>
                            <div class="server-header-actions">
                                ${servers.length > 1 ? `
                                    <button type="button" class="remove-server-btn" onclick="event.stopPropagation(); removeServerFromStep('${stepId}', ${server.id})">
                                        Remove
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="server-card-body">
                            ${purposeOptions}
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Hostname / IP</label>
                                    <input type="text" class="form-input" placeholder="10.0.0.20"
                                           value="${server.hostname || ''}"
                                           onchange="updateServerField('${stepId}', ${server.id}, 'hostname', this.value)">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">SSH Port</label>
                                    <input type="number" class="form-input" placeholder="22"
                                           value="${server.ssh_port || 22}"
                                           onchange="updateServerField('${stepId}', ${server.id}, 'ssh_port', parseInt(this.value))">
                                </div>
                            </div>

                            <!-- SSH Connection Settings -->
                            <div class="form-group">
                                <label class="form-label">SSH User Type</label>
                                <div class="radio-group horizontal">
                                    <label class="radio-option ${sshUserType === 'root' ? 'selected' : ''}"
                                           onclick="updateServerField('${stepId}', ${server.id}, 'ssh_user_type', 'root'); updateServerField('${stepId}', ${server.id}, 'ssh_user', 'root'); renderServers('${stepId}');">
                                        <input type="radio" name="user_type_${server.id}" value="root" ${sshUserType === 'root' ? 'checked' : ''}>
                                        <div class="radio-option-content">
                                            <div class="radio-option-label">Root User</div>
                                            <div class="radio-option-desc">Direct root access</div>
                                        </div>
                                    </label>
                                    <label class="radio-option ${sshUserType === 'sudo' ? 'selected' : ''}"
                                           onclick="updateServerField('${stepId}', ${server.id}, 'ssh_user_type', 'sudo'); renderServers('${stepId}');">
                                        <input type="radio" name="user_type_${server.id}" value="sudo" ${sshUserType === 'sudo' ? 'checked' : ''}>
                                        <div class="radio-option-content">
                                            <div class="radio-option-label">Sudo User</div>
                                            <div class="radio-option-desc">Escalate to root</div>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            ${sshUserType === 'sudo' ? `
                                <div class="form-group">
                                    <label class="form-label">Username</label>
                                    <input type="text" class="form-input" placeholder="e.g., ubuntu, admin"
                                           value="${server.ssh_user || ''}"
                                           onchange="updateServerField('${stepId}', ${server.id}, 'ssh_user', this.value)">
                                    <span style="color: var(--color-text-muted); font-size: 0.75rem;">User with sudo privileges</span>
                                </div>
                            ` : ''}

                            <!-- SSH Authentication Method -->
                            <div class="form-group">
                                <label class="form-label">Authentication Method</label>
                                <select class="form-select" onchange="updateServerField('${stepId}', ${server.id}, 'ssh_auth_type', this.value); renderServers('${stepId}');">
                                    <option value="password" ${sshAuthType === 'password' ? 'selected' : ''}>Password Authentication</option>
                                    <option value="key" ${sshAuthType === 'key' ? 'selected' : ''}>SSH Private Key</option>
                                </select>
                            </div>

                            ${authFields}
                            ${sudoPasswordField}
                        </div>
                    </div>
                `;
            }).join('');

            // Update add button visibility
            const addBtn = document.getElementById(`add-btn-${stepId}`);
            if (addBtn) {
                // Only show add button for env-check (editable, multi-server)
                // Hide for all other steps since they are read-only (pre-filled from env-check)
                if (stepId === 'env-check') {
                    addBtn.style.display = 'flex';
                } else {
                    addBtn.style.display = 'none';
                }
            }
        }

        // Debounce timer for saving servers to database
        let serverSaveTimer = null;

        function updateServerField(stepId, serverId, field, value) {
            const server = state.servers[stepId]?.find(s => s.id === serverId);
            if (server) {
                server[field] = value;

                // Re-render servers when purpose changes (to update badge and filter options)
                if (field === 'purpose') {
                    renderServers(stepId);
                }

                // Debounce database save (wait 1 second after last change)
                clearTimeout(serverSaveTimer);
                serverSaveTimer = setTimeout(() => {
                    saveServersToDb(stepId);
                }, 1000);
            }
        }

        function setMode(stepId, mode) {
            state.modes[stepId] = mode;
            state.servers[stepId] = [];
            addServerToStep(stepId);

            // Re-render the form
            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);
            document.getElementById('panelContent').innerHTML = generateStepForm(step);
            renderServers(stepId);
        }

        // SSL Configuration functions
        function setSSLType(type) {
            state.sslConfig.type = type;
            saveState();

            // Toggle visibility of forms based on SSL type
            const letsencryptInfo = document.getElementById('ssl-letsencrypt-info');
            const uploadForm = document.getElementById('ssl-upload-form');
            const autoUploadFields = document.getElementById('auto-ssl-upload-fields');

            if (letsencryptInfo) letsencryptInfo.style.display = type === 'letsencrypt' ? 'block' : 'none';
            if (uploadForm) uploadForm.style.display = type === 'upload' ? 'block' : 'none';
            if (autoUploadFields) autoUploadFields.style.display = type === 'upload' ? 'block' : 'none';

            // Re-render form to update radio button styles (for both SSL and loadbalancer panels)
            if (state.activePanel === 'ssl' || state.activePanel === 'loadbalancer') {
                const step = DEPLOYMENT_STEPS.find(s => s.id === state.activePanel);
                if (step) {
                    document.getElementById('panelContent').innerHTML = generateStepForm(step);
                    renderServers(state.activePanel);
                }
            }

            // If we're in env-check panel, re-render it to update SSL form visibility
            if (state.activePanel === 'env-check') {
                const step = DEPLOYMENT_STEPS.find(s => s.id === 'env-check');
                if (step) {
                    document.getElementById('panelContent').innerHTML = generateStepForm(step);
                    renderServers('env-check');
                }
            }
        }

        // Load Balancer Configuration functions
        function setLoadBalancerType(type) {
            state.loadBalancerConfig.type = type;
            saveState();

            // Re-render form to update radio button styles
            if (state.activePanel === 'loadbalancer') {
                const step = DEPLOYMENT_STEPS.find(s => s.id === 'loadbalancer');
                if (step) {
                    document.getElementById('panelContent').innerHTML = generateStepForm(step);
                    renderServers('loadbalancer');
                }
            }
        }

        function updateLoadBalancerConfig(field, value) {
            if (!state.loadBalancerConfig) {
                state.loadBalancerConfig = { type: 'haproxy', backendPort: '30080' };
            }
            state.loadBalancerConfig[field] = value;
            saveState();
        }

        // Set automation mode (manual or auto)
        function setAutomationMode(mode) {
            state.automationMode = mode;
            saveState();
            renderSummary();

            // Update the auto-complete config section visibility in env-check form if it's open
            const configEl = document.getElementById('auto-complete-config');
            if (configEl) {
                configEl.style.display = mode === 'auto' ? 'block' : 'none';
            }

            // Re-render env-check form to update radio button styles
            if (state.activePanel === 'env-check') {
                const step = DEPLOYMENT_STEPS.find(s => s.id === 'env-check');
                document.getElementById('panelContent').innerHTML = generateStepForm(step);
                renderServers('env-check');
            }
        }

        // Update NFS configuration
        function updateNfsConfig(field, value) {
            state.nfsConfig[field] = value;
            saveState();
        }

        function updateSSLConfig(field, value) {
            state.sslConfig[field] = value;
            saveState();
        }

        // ==================== EXECUTION ====================
        // DEMO MODE FLAG - Set to false to use real API calls
        // Set to false for production deployments
        const DEMO_MODE = false;

        async function executeStep(stepId) {
            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);
            const servers = state.servers[stepId] || [];

            // Clear any previous error/success message and reset progress UI
            hideResult(stepId);
            resetProgressUI(stepId);

            // Validation - check hostname
            if (servers.length === 0 || servers.some(s => !s.hostname)) {
                showResult(stepId, 'error', 'Please fill in at least the hostname/IP for all servers.');
                return;
            }

            // Production validation - check authentication credentials
            if (!DEMO_MODE) {
                for (const server of servers) {
                    const authType = server.ssh_auth_type || 'password';
                    if (authType === 'password' && !server.password) {
                        showResult(stepId, 'error', `Please provide SSH password for server ${server.hostname}`);
                        return;
                    }
                    if (authType === 'key' && !server.ssh_key) {
                        showResult(stepId, 'error', `Please provide SSH private key for server ${server.hostname}`);
                        return;
                    }
                }
            }

            // SSL-specific validation (for both ssl and loadbalancer steps)
            if (stepId === 'ssl' || stepId === 'loadbalancer') {
                if (!state.sslConfig.domain) {
                    showResult(stepId, 'error', 'Please enter a domain name for the SSL certificate.');
                    return;
                }
                if (state.sslConfig.type === 'upload') {
                    if (!state.sslConfig.certificate || !state.sslConfig.privateKey) {
                        showResult(stepId, 'error', 'Please provide both the SSL certificate and private key.');
                        return;
                    }
                }
            }

            // Show progress
            const submitBtn = document.getElementById(`submit-${stepId}`);
            const progressSection = document.getElementById(`progress-${stepId}`);
            const taskList = document.getElementById(`task-list-${stepId}`);
            const progressBar = document.getElementById(`progress-bar-${stepId}`);
            const progressPct = document.getElementById(`progress-pct-${stepId}`);

            submitBtn.disabled = true;
            const actionText = step.type === 'check' ? 'Checking...' : 'Deploying...';
            submitBtn.innerHTML = `<div class="spinner"></div> ${actionText}`;
            progressSection.classList.add('visible');
            taskList.innerHTML = '';
            // Reset progress bar to 0% at start
            progressBar.style.width = '0%';
            progressPct.textContent = '0%';

            if (DEMO_MODE) {
                // Simulate deployment with demo tasks
                await simulateDeployment(stepId, step, servers, taskList, progressBar, progressPct, submitBtn);
            } else {
                // Real API call mode
                await executeRealDeployment(stepId, step, servers, taskList, progressBar, progressPct, submitBtn);
            }
        }

        // Demo simulation function
        async function simulateDeployment(stepId, step, servers, taskList, progressBar, progressPct, submitBtn) {
            const demoTasks = getDemoTasks(stepId, servers);
            const totalTasks = demoTasks.length;
            const totalServers = servers.length;
            let completedTasks = 0;

            for (const task of demoTasks) {
                // Add task to list (pending)
                addTaskItem(taskList, task.name, totalServers);
                await sleep(300 + Math.random() * 400);

                // Simulate all servers completing successfully
                const taskData = {
                    success: new Set(servers.map((s, i) => s.name || s.purpose || s.role || `server-${i}`)),
                    failed: new Set(),
                    skipped: new Set()
                };
                updateTaskItem(taskList, task.name, taskData, totalServers);

                // Update progress
                completedTasks++;
                const pct = Math.round((completedTasks / totalTasks) * 100);
                progressBar.style.width = `${pct}%`;
                progressPct.textContent = `${pct}%`;
            }

            // Generate demo credentials for certain steps
            if (['mysql', 'mongodb', 'rabbitmq'].includes(stepId)) {
                const creds = generateDemoCredentials(stepId);
                state.credentials[stepId] = creds;
                renderCredentials(stepId);

                // Save credentials to database
                await saveCredentialsToDb(stepId, creds);

                // Save credential file for auto-download
                const credContent = `# ${stepId.toUpperCase()} Credentials\n# Generated: ${new Date().toISOString()}\n\n` +
                    Object.entries(creds).map(([k, v]) => `${k.toUpperCase()}=${v}`).join('\n');
                await saveGeneratedFile(stepId, `${stepId}-credentials.txt`, credContent);
            }

            // Mark step as complete
            state.completedSteps.add(stepId);
            state.stepData[stepId] = { servers: servers, completedAt: new Date().toISOString() };
            saveState();

            // Save step completion to database
            await markStepCompleteInDb(stepId, state.stepData[stepId]);

            // Show success
            showResult(stepId, 'success', `${step.fullTitle} completed successfully!`);
            submitBtn.innerHTML = `<span>&#10003;</span> Completed`;
            submitBtn.classList.add('success');

            // Update UI
            renderProgressSteps();
            renderStepCards();
            renderSummary();

            // Check if this is the last step (stackbill) - trigger auto-download and cleanup
            if (stepId === 'stackbill') {
                await handleDeploymentComplete();
            }

            // Auto-complete mode: automatically proceed to next step
            if (state.automationMode === 'auto') {
                await autoCompleteNextStep(stepId);
            }
        }

        // Auto-complete: proceed to the next step automatically
        async function autoCompleteNextStep(completedStepId) {
            // Find the next incomplete step
            const currentIndex = DEPLOYMENT_STEPS.findIndex(s => s.id === completedStepId);
            const nextStep = DEPLOYMENT_STEPS.slice(currentIndex + 1).find(step => !state.completedSteps.has(step.id));

            if (!nextStep) {
                console.log('Auto-complete: All steps completed!');
                showToast('All deployment steps completed!', 'success');
                return;
            }

            // Check if next step requires manual configuration
            const requiresManualConfig = checkStepRequiresManualConfig(nextStep);
            if (requiresManualConfig) {
                showToast(`Auto-complete paused: ${nextStep.fullTitle} requires configuration`, 'warning');
                // Open the panel but don't auto-submit
                closePanel();
                await new Promise(resolve => setTimeout(resolve, 500));
                openStepPanel(nextStep.id);
                return;
            }

            // Close current panel first
            closePanel();

            // Show notification about auto-proceeding
            showToast(`Auto-proceeding to ${nextStep.fullTitle}...`, 'info');

            // Small delay for user to see the notification
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Pre-populate servers from env-check for deployment steps
            if (nextStep.type !== 'check' && state.completedSteps.has('env-check')) {
                const detectedMode = detectDeploymentMode(nextStep.id);
                if (nextStep.hasMode) {
                    state.modes[nextStep.id] = detectedMode;
                }
                populateServersFromEnvCheck(nextStep.id);
            }

            // Open and auto-run the next step
            openStepPanel(nextStep.id);

            // Auto-click the submit button after a short delay (for UI to render)
            await new Promise(resolve => setTimeout(resolve, 500));

            const submitBtn = document.getElementById('stepSubmitBtn');
            if (submitBtn && !submitBtn.disabled) {
                // Validate that we have servers configured
                const servers = state.servers[nextStep.id] || [];
                if (servers.length > 0 && servers.every(s => s.hostname && (s.password || s.ssh_key))) {
                    submitBtn.click();
                } else {
                    // Can't auto-proceed - missing server configuration
                    console.log('Auto-complete paused - servers:', servers);
                    showToast(`Auto-complete paused: ${nextStep.fullTitle} requires server configuration`, 'warning');
                }
            }
        }

        // Check if a step requires manual configuration before proceeding
        // Returns false if pre-collected config exists (from Auto-Complete config in env-check)
        function checkStepRequiresManualConfig(step) {
            // Load Balancer step requires domain name at minimum (includes SSL config)
            if (step.id === 'loadbalancer') {
                const sslDomain = state.sslConfig?.domain;
                const sslType = state.sslConfig?.type || 'letsencrypt';
                // For upload type, also need certificate and key
                if (sslType === 'upload') {
                    return !sslDomain || !state.sslConfig?.certificate || !state.sslConfig?.privateKey;
                }
                // If domain is pre-configured, no manual config needed
                return !sslDomain;
            }

            // SSL step is now optional and always allows auto-proceed if loadbalancer was done
            if (step.id === 'ssl') {
                // If loadbalancer step is already completed, SSL is optional
                if (state.completedSteps.has('loadbalancer')) {
                    return false; // Can auto-proceed, SSL was configured in loadbalancer step
                }
                // Otherwise, check SSL config
                const sslDomain = state.sslConfig?.domain;
                const sslType = state.sslConfig?.type || 'letsencrypt';
                if (sslType === 'upload') {
                    return !sslDomain || !state.sslConfig?.certificate || !state.sslConfig?.privateKey;
                }
                return !sslDomain;
            }

            // NFS step - disk is now optional, so no manual config needed for auto-complete
            if (step.id === 'nfs') {
                // NFS can proceed with or without disk (directory-only mode is valid)
                return false;
            }

            return false;
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            // Create toast element if it doesn't exist
            let toast = document.getElementById('autoCompleteToast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'autoCompleteToast';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 0.9rem;
                    font-weight: 500;
                    z-index: 10000;
                    transition: opacity 0.3s, transform 0.3s;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                document.body.appendChild(toast);
            }

            // Set color based on type
            const colors = {
                info: { bg: 'var(--primary)', text: 'white' },
                success: { bg: 'var(--success)', text: 'white' },
                warning: { bg: 'var(--warning)', text: 'white' },
                error: { bg: 'var(--error)', text: 'white' }
            };
            const color = colors[type] || colors.info;
            toast.style.background = color.bg;
            toast.style.color = color.text;
            toast.textContent = message;
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(-50%) translateY(0)';

            // Auto-hide after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(20px)';
            }, 3000);
        }

        // Handle full deployment completion
        async function handleDeploymentComplete() {
            // Generate and download all credentials
            await autoDownloadCredentials();

            // Auto-cleanup if enabled (from global settings)
            if (globalSettings.autoCleanup) {
                await cleanupSessionData();
                showResult('stackbill', 'success',
                    'Deployment completed! Credentials have been downloaded and sensitive data has been cleaned up.');
            }
        }

        // Auto-download all credentials as a single JSON file
        async function autoDownloadCredentials() {
            try {
                const response = await fetch(`/api/sessions/${state.sessionId}/export`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `stackbill-credentials-${state.sessionId.substring(0, 8)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log('Credentials auto-downloaded');
                }
            } catch (e) {
                console.error('Failed to auto-download credentials:', e);
            }
        }

        // Get demo tasks based on step
        function getDemoTasks(stepId, servers) {
            const serverCount = servers.length;
            const tasks = {
                'env-check': [
                    { name: 'Gathering system facts' },
                    { name: 'Verifying Ubuntu version (22.04+)' },
                    { name: 'Checking CPU and memory resources' },
                    { name: 'Checking disk space' },
                    { name: 'Testing internet connectivity' },
                    { name: 'Verifying DNS resolution' },
                    { name: 'Testing S3 repository access' },
                    { name: 'Checking firewall status' },
                    { name: 'Verifying APT package manager' },
                    { name: 'Environment check summary' }
                ],
                'kubernetes': [
                    { name: 'Installing prerequisites' },
                    { name: 'Disabling swap' },
                    { name: 'Loading kernel modules' },
                    { name: 'Configuring sysctl' },
                    { name: 'Installing containerd' },
                    { name: 'Adding Kubernetes repository' },
                    { name: 'Installing kubelet, kubeadm, kubectl' },
                    { name: 'Initializing Kubernetes master' },
                    { name: 'Installing Flannel CNI' },
                    { name: 'Joining worker nodes' },
                    { name: 'Verifying cluster status' }
                ],
                'mysql': serverCount > 1 ? [
                    { name: 'Installing MySQL 8.0' },
                    { name: 'Configuring MySQL server' },
                    { name: 'Setting up replication user' },
                    { name: 'Configuring primary server' },
                    { name: 'Configuring secondary server' },
                    { name: 'Starting replication' },
                    { name: 'Verifying replication status' },
                    { name: 'Generating credentials' }
                ] : [
                    { name: 'Installing MySQL 8.0' },
                    { name: 'Configuring MySQL server' },
                    { name: 'Setting root password' },
                    { name: 'Creating stackbill user' },
                    { name: 'Generating credentials' }
                ],
                'mongodb': serverCount > 1 ? [
                    { name: 'Installing MongoDB 7.0' },
                    { name: 'Configuring MongoDB' },
                    { name: 'Generating keyfile' },
                    { name: 'Distributing keyfile' },
                    { name: 'Initializing replica set' },
                    { name: 'Adding secondary nodes' },
                    { name: 'Creating admin user' },
                    { name: 'Verifying replica set' },
                    { name: 'Generating credentials' }
                ] : [
                    { name: 'Installing MongoDB 7.0' },
                    { name: 'Configuring MongoDB' },
                    { name: 'Enabling authentication' },
                    { name: 'Creating admin user' },
                    { name: 'Generating credentials' }
                ],
                'rabbitmq': [
                    { name: 'Adding RabbitMQ repository' },
                    { name: 'Installing Erlang' },
                    { name: 'Installing RabbitMQ server' },
                    { name: 'Enabling management plugin' },
                    { name: 'Creating admin user' },
                    { name: 'Configuring permissions' },
                    { name: 'Generating credentials' }
                ],
                'nfs': [
                    { name: 'Installing NFS server' },
                    { name: 'Creating storage directory' },
                    { name: 'Configuring exports' },
                    { name: 'Setting permissions' },
                    { name: 'Restarting NFS service' },
                    { name: 'Verifying NFS mount' }
                ],
                'kubectl': [
                    { name: 'Downloading kubectl' },
                    { name: 'Installing kubectl' },
                    { name: 'Creating kubeconfig directory' },
                    { name: 'Copying kubeconfig' },
                    { name: 'Downloading Istio 1.20.3' },
                    { name: 'Installing istioctl' },
                    { name: 'Installing Istio' },
                    { name: 'Verifying Istio installation' }
                ],
                'helm': [
                    { name: 'Downloading Helm' },
                    { name: 'Installing Helm' },
                    { name: 'Verifying Helm installation' },
                    { name: 'Adding StackBill repository' }
                ],
                'loadbalancer': (() => {
                    const lbType = state.loadBalancerConfig?.type || 'haproxy';
                    const sslType = state.sslConfig?.type || 'letsencrypt';
                    const domain = state.sslConfig?.domain || 'domain';
                    const baseTasks = lbType === 'nginx'
                        ? [{ name: 'Installing Nginx' }, { name: 'Creating SSL directory' }]
                        : [{ name: 'Installing HAProxy' }, { name: 'Creating SSL directory' }];
                    const sslTasks = sslType === 'upload'
                        ? [{ name: 'Writing SSL certificate (fullchain.pem)' }, { name: 'Writing private key (privkey.pem)' }, ...(lbType === 'haproxy' ? [{ name: 'Creating combined PEM file' }] : [])]
                        : [{ name: 'Installing certbot' }, { name: `Requesting Let's Encrypt certificate for ${domain}` }, ...(lbType === 'haproxy' ? [{ name: 'Creating combined PEM file' }] : [{ name: 'Verifying certificate' }])];
                    const configTasks = lbType === 'nginx'
                        ? [{ name: 'Configuring Nginx sites' }, { name: 'Setting up upstream servers' }, { name: 'Enabling HTTPS redirect' }, { name: 'Testing Nginx configuration' }, { name: 'Restarting Nginx service' }, { name: 'Verifying load balancer' }]
                        : [{ name: 'Configuring HAProxy frontend' }, { name: 'Configuring backend servers' }, { name: 'Enabling statistics page' }, { name: 'Testing HAProxy configuration' }, { name: 'Restarting HAProxy service' }, { name: 'Verifying load balancer' }];
                    return [...baseTasks, ...sslTasks, ...configTasks];
                })(),
                'ssl': state.sslConfig.type === 'upload' ? [
                    { name: 'Creating SSL directory' },
                    { name: 'Validating certificate format' },
                    { name: 'Validating private key format' },
                    { name: 'Writing fullchain certificate to server' },
                    { name: 'Writing private key to server' },
                    { name: 'Creating combined PEM for HAProxy' },
                    { name: 'Setting file permissions' },
                    { name: 'Verifying certificate' }
                ] : [
                    { name: 'Installing certbot' },
                    { name: 'Creating SSL directory' },
                    { name: `Requesting Let's Encrypt certificate for ${state.sslConfig.domain || 'domain'}` },
                    { name: 'Copying certificate files' },
                    { name: 'Creating combined PEM for HAProxy' },
                    { name: 'Setting file permissions' },
                    { name: 'Verifying certificate' }
                ],
                'stackbill': [
                    { name: 'Verifying cluster connectivity' },
                    { name: 'Creating StackBill namespace' },
                    { name: 'Configuring NFS storage class' },
                    { name: 'Preparing Helm values' },
                    { name: 'Deploying StackBill application' },
                    { name: 'Waiting for pods to be ready' },
                    { name: 'Verifying deployment' }
                ]
            };
            return tasks[stepId] || [{ name: 'Executing deployment tasks' }];
        }

        // Generate demo credentials
        function generateDemoCredentials(stepId) {
            const randomPass = () => Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-4).toUpperCase();

            const creds = {
                'mysql': { username: 'stackbill', password: randomPass(), port: '3306' },
                'mongodb': { username: 'admin', password: randomPass(), port: '27017' },
                'rabbitmq': { username: 'mqadmin', password: randomPass(), port: '5672' }
            };
            return creds[stepId] || {};
        }

        // Sleep helper
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Real API deployment (for when DEMO_MODE is false)
        async function executeRealDeployment(stepId, step, servers, taskList, progressBar, progressPct, submitBtn) {
            const mode = state.modes[stepId] || 'single';

            // Prepare payload
            const payload = {
                servers: servers.map(s => ({
                    hostname: s.hostname,
                    ssh_port: s.ssh_port,
                    ssh_auth_type: s.ssh_auth_type || 'password',
                    ssh_user: s.ssh_user || 'root',
                    ssh_user_type: s.ssh_user_type || 'root',
                    password: s.password,
                    ssh_key: s.ssh_key || '',
                    sudo_password: s.sudo_password || '',
                    role: s.role
                })),
                variables: {
                    deployment_mode: mode
                }
            };

            // Add extra fields for NFS - use form values or pre-collected config
            if (stepId === 'nfs') {
                payload.variables.disk_device = document.getElementById('disk_device')?.value || state.nfsConfig?.diskDevice || '';
                payload.variables.nfs_client_ip_range = document.getElementById('client_ip_range')?.value || state.nfsConfig?.clientIpRange || '*';
            }

            // Add SSL configuration for loadbalancer and ssl steps
            if (stepId === 'loadbalancer' || stepId === 'ssl') {
                payload.variables.ssl_certificate_type = state.sslConfig?.type || 'letsencrypt';
                payload.variables.domain_name = state.sslConfig?.domain || '';
                // For upload type, include certificate content
                if (state.sslConfig?.type === 'upload') {
                    payload.variables.fullchain_certificate = state.sslConfig?.certificate || '';
                    payload.variables.private_key = state.sslConfig?.privateKey || '';
                }
            }

            // Add load balancer specific config
            if (stepId === 'loadbalancer') {
                payload.variables.load_balancer_type = state.loadBalancerConfig?.type || 'haproxy';
                payload.variables.backend_port = state.loadBalancerConfig?.backendPort || '30080';
            }

            let completedTasks = 0;
            let totalTasks = 0;
            let currentTaskName = '';
            const failedHosts = new Set(); // Track which hosts have failed
            const totalServers = servers.length;

            // Create mapping from Ansible host names (server-0, server-1) to friendly names
            const hostNameMap = {};
            servers.forEach((server, idx) => {
                const ansibleHostName = `server-${idx}`;
                const friendlyName = server.name || server.purpose || server.role || ansibleHostName;
                hostNameMap[ansibleHostName] = friendlyName;
            });

            // Track per-task server results: taskName -> { success: Set, failed: Set, skipped: Set, errors: Map }
            const taskResults = new Map();
            let lastErrorMessage = null; // Store last error for final display

            try {
                // Include session ID in URL for logging traceability
                const sessionParam = state.sessionId ? `&sessionId=${state.sessionId}` : '';
                const response = await fetch(`/api/playbook/${stepId}?stream=true${sessionParam}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream'
                    },
                    body: JSON.stringify({ ...payload, sessionId: state.sessionId })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                function updateProgress(forceComplete = false) {
                    // Cap at 99% until we get the actual complete event to avoid false 100%
                    let pct = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
                    if (!forceComplete && pct >= 100) {
                        pct = 99; // Show 99% max until playbook actually completes
                    }
                    progressBar.style.width = `${pct}%`;
                    progressPct.textContent = `${pct}%`;
                }

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                handleStreamEvent(stepId, data, taskList, progressBar, progressPct,
                                    (taskName) => {
                                        // New task started
                                        totalTasks++;
                                        currentTaskName = taskName;
                                    },
                                    (taskName) => {
                                        // Task completed - only count once per unique task
                                        // (task_result fires for each host, but we want to count the task once)
                                        if (taskName === currentTaskName) {
                                            completedTasks++;
                                            currentTaskName = ''; // Clear so we don't double-count
                                            updateProgress();
                                        }
                                    },
                                    failedHosts,
                                    hostNameMap,
                                    taskResults,
                                    totalServers);
                            } catch (e) {
                                console.error('Error parsing SSE:', e);
                            }
                        }
                    }
                }

            } catch (error) {
                showResult(stepId, 'error', error.message);
                submitBtn.disabled = false;
                const retryText = step.type === 'check'
                    ? `<span>&#9989;</span> Run Environment Check`
                    : `<span>&#128640;</span> Deploy ${step.title}`;
                submitBtn.innerHTML = retryText;
            }
        }

        function handleStreamEvent(stepId, data, taskList, progressBar, progressPct, onTask, onComplete, failedHosts = null, hostNameMap = {}, taskResults = null, totalServers = 1) {
            const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);

            // Helper to get friendly host name
            const getFriendlyHostName = (host) => hostNameMap[host] || host;

            if (data.type === 'task') {
                onTask(data.task);
                // Add task item with total server count for badge display
                addTaskItem(taskList, data.task, totalServers);

                // Initialize task results tracking
                if (taskResults && !taskResults.has(data.task)) {
                    taskResults.set(data.task, {
                        success: new Set(),
                        failed: new Set(),
                        skipped: new Set()
                    });
                }
            } else if (data.type === 'task_result') {
                onComplete(data.task);

                const friendlyHost = data.host ? getFriendlyHostName(data.host) : null;

                // Update per-task tracking
                if (taskResults) {
                    if (!taskResults.has(data.task)) {
                        taskResults.set(data.task, {
                            success: new Set(),
                            failed: new Set(),
                            skipped: new Set(),
                            errors: new Map() // Map of host -> error message
                        });
                    }

                    const taskData = taskResults.get(data.task);

                    if (data.status === 'ok' || data.status === 'changed') {
                        if (friendlyHost) taskData.success.add(friendlyHost);
                    } else if (data.status === 'fatal') {
                        if (friendlyHost) {
                            taskData.failed.add(friendlyHost);
                            // Store actual error message if available
                            if (data.errorMessage) {
                                taskData.errors.set(friendlyHost, data.errorMessage);
                            }
                        }
                    } else if (data.status === 'skipping') {
                        if (friendlyHost) taskData.skipped.add(friendlyHost);
                    }

                    // Update task item display with current counts
                    updateTaskItem(taskList, data.task, taskData, totalServers);
                }

                // Track failed hosts and error messages for final error messaging
                if (data.status === 'fatal' && friendlyHost && failedHosts) {
                    failedHosts.add(friendlyHost);
                    // Capture error message for final display
                    if (data.errorMessage) {
                        lastErrorMessage = data.errorMessage;
                    }
                }

                // Handle credentials
                if (data.credentialUpdate && data.credentialUpdate.service) {
                    state.credentials[data.credentialUpdate.service] = {
                        ...state.credentials[data.credentialUpdate.service],
                        ...data.credentialUpdate.data
                    };
                    renderCredentials(stepId);
                }
            } else if (data.type === 'complete') {
                const submitBtn = document.getElementById(`submit-${stepId}`);
                submitBtn.disabled = false;
                submitBtn.innerHTML = `<span>&#128640;</span> Deploy ${step.title}`;

                // Set progress to 100% on completion
                progressBar.style.width = '100%';
                progressPct.textContent = '100%';

                // Convert taskResults Map to serializable object for persistence
                const taskResultsObj = {};
                if (taskResults) {
                    for (const [taskName, result] of taskResults) {
                        taskResultsObj[taskName] = {
                            success: Array.from(result.success || []),
                            failed: Array.from(result.failed || []),
                            skipped: Array.from(result.skipped || []),
                            errors: result.errors ? Object.fromEntries(result.errors) : {}
                        };
                    }
                }

                if (data.success) {
                    state.completedSteps.add(stepId);
                    state.stepData[stepId] = { servers: state.servers[stepId] };
                    saveState();

                    showResult(stepId, 'success', 'Deployment completed successfully!');

                    // Handle credentials
                    if (data.credentials && data.credentials[stepId]) {
                        state.credentials[stepId] = data.credentials[stepId];
                        renderCredentials(stepId);
                    }

                    renderProgressSteps();
                    renderStepCards();
                    renderSummary();

                    // Save step completion to database (with task results for persistence)
                    markStepCompleteInDb(stepId, state.stepData[stepId], 'completed', taskResultsObj);

                    // Auto-complete mode: automatically proceed to next step
                    if (state.automationMode === 'auto') {
                        // Small delay before auto-proceeding to let UI update
                        setTimeout(() => autoCompleteNextStep(stepId), 2000);
                    }
                } else {
                    // Build detailed error message with failed hosts and actual error
                    let errorMsg = data.error || 'Deployment failed. Check the task list for details.';
                    if (failedHosts && failedHosts.size > 0) {
                        const hostList = Array.from(failedHosts).join(', ');
                        errorMsg += `<br><br><strong>Failed servers:</strong> ${hostList}`;
                        // Show actual error message if available
                        if (lastErrorMessage) {
                            const truncatedError = lastErrorMessage.length > 300
                                ? lastErrorMessage.substring(0, 300) + '...'
                                : lastErrorMessage;
                            errorMsg += `<br><br><strong>Error:</strong> <code style="word-break: break-all;">${truncatedError}</code>`;
                        } else {
                            errorMsg += '<br><small>Check SSH credentials and connectivity for these servers.</small>';
                        }
                    }
                    showResult(stepId, 'error', errorMsg);

                    // Save step FAILURE to database (so it persists across restarts)
                    markStepCompleteInDb(stepId, { error: errorMsg, failedHosts: Array.from(failedHosts || []) }, 'failed', taskResultsObj);
                }
            }
        }

        /**
         * Create a task ID from task name for DOM lookup
         */
        function getTaskId(taskName) {
            return `task-${taskName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`;
        }

        /**
         * Add a new task item to the task list (called when TASK event received)
         */
        function addTaskItem(container, taskName, totalServers) {
            const taskId = getTaskId(taskName);

            // Check if task already exists
            if (container.querySelector(`[data-task-id="${taskId}"]`)) {
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'task-item-wrapper';
            wrapper.dataset.taskId = taskId;

            const badgeText = totalServers === 1 ? '[Pending]' : `[0/${totalServers}]`;

            wrapper.innerHTML = `
                <div class="task-item running">
                    <span class="task-icon">&#9711;</span>
                    <span class="task-name">${taskName}</span>
                    <span class="task-badge">${badgeText}</span>
                </div>
                <div class="task-failure-details"></div>
            `;

            container.appendChild(wrapper);
            container.scrollTop = container.scrollHeight;
        }

        /**
         * Update a task item with server completion results
         */
        function updateTaskItem(container, taskName, taskData, totalServers) {
            const taskId = getTaskId(taskName);
            const wrapper = container.querySelector(`[data-task-id="${taskId}"]`);

            if (!wrapper) return;

            const taskItem = wrapper.querySelector('.task-item');
            const icon = wrapper.querySelector('.task-icon');
            const badge = wrapper.querySelector('.task-badge');
            const failureDetails = wrapper.querySelector('.task-failure-details');

            const successCount = taskData.success.size;
            const failedCount = taskData.failed.size;
            const skippedCount = taskData.skipped ? taskData.skipped.size : 0;
            const completedCount = successCount + failedCount + skippedCount;
            const isComplete = completedCount >= totalServers;

            // Determine status
            if (failedCount > 0) {
                // Has failures
                taskItem.className = 'task-item error';
                icon.innerHTML = '&#10007;';
                if (totalServers === 1) {
                    badge.textContent = '[Failed]';
                } else {
                    badge.textContent = `[${successCount}/${totalServers}]`;
                }

                // Build detailed failure message with actual errors
                let failureHtml = ` Failed: ${Array.from(taskData.failed).join(', ')}`;
                if (taskData.errors && taskData.errors.size > 0) {
                    const firstError = taskData.errors.values().next().value;
                    if (firstError) {
                        // Truncate long error messages
                        const truncatedError = firstError.length > 200
                            ? firstError.substring(0, 200) + '...'
                            : firstError;
                        failureHtml += `<br><small style="color:#dc3545; margin-left:20px;">Error: ${truncatedError}</small>`;
                    }
                }
                failureDetails.innerHTML = failureHtml;
                failureDetails.style.display = 'block';
            } else if (skippedCount === totalServers) {
                // All skipped
                taskItem.className = 'task-item skipped';
                icon.innerHTML = '&#8594;';
                badge.textContent = totalServers === 1 ? '[Skipped]' : `[Skipped]`;
            } else if (isComplete) {
                // All success
                taskItem.className = 'task-item success';
                icon.innerHTML = '&#10003;';
                if (totalServers === 1) {
                    badge.textContent = '[Done]';
                } else {
                    badge.textContent = `[${totalServers}/${totalServers}]`;
                }
            } else {
                // Still running
                taskItem.className = 'task-item running';
                icon.innerHTML = '&#9711;';
                if (totalServers === 1) {
                    badge.textContent = '[Running...]';
                } else {
                    badge.textContent = `[${completedCount}/${totalServers}]`;
                }
            }

            container.scrollTop = container.scrollHeight;
        }

        function renderCredentials(stepId) {
            const container = document.getElementById(`creds-${stepId}`);
            const content = document.getElementById(`creds-content-${stepId}`);
            const creds = state.credentials[stepId];

            if (!creds || Object.keys(creds).length === 0) {
                container.classList.remove('visible');
                return;
            }

            container.classList.add('visible');
            content.innerHTML = Object.entries(creds).map(([key, value]) => `
                <div class="credential-row">
                    <span class="credential-label">${key}</span>
                    <span class="credential-value">${value}</span>
                    <button class="copy-btn" onclick="copyToClipboard('${value}', this)">Copy</button>
                </div>
            `).join('');
        }

        function showResult(stepId, type, message) {
            const result = document.getElementById(`result-${stepId}`);
            result.className = `result-message visible ${type}`;
            result.innerHTML = `
                <strong>${type === 'success' ? '&#10003; Success' : '&#10007; Error'}</strong>
                <p>${message}</p>
            `;
        }

        function hideResult(stepId) {
            const result = document.getElementById(`result-${stepId}`);
            if (result) {
                result.className = 'result-message';
                result.innerHTML = '';
            }
        }

        function resetProgressUI(stepId) {
            const progressBar = document.getElementById(`progress-bar-${stepId}`);
            const progressPct = document.getElementById(`progress-pct-${stepId}`);
            const taskList = document.getElementById(`task-list-${stepId}`);

            if (progressBar) progressBar.style.width = '0%';
            if (progressPct) progressPct.textContent = '0%';
            if (taskList) taskList.innerHTML = '';
        }

        // ==================== UTILITIES ====================
        function toggleSummary() {
            const sidebar = document.getElementById('summarySidebar');
            const overlay = document.getElementById('summaryOverlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('open');
            renderSummary();
        }

        function togglePasswordVisibility(inputId, button) {
            const input = document.getElementById(inputId);
            if (!input) return;

            const eyeIcon = button.querySelector('.eye-icon');
            const eyeOffIcon = button.querySelector('.eye-off-icon');

            if (input.type === 'password') {
                input.type = 'text';
                if (eyeIcon) eyeIcon.style.display = 'none';
                if (eyeOffIcon) eyeOffIcon.style.display = 'block';
            } else {
                input.type = 'password';
                if (eyeIcon) eyeIcon.style.display = 'block';
                if (eyeOffIcon) eyeOffIcon.style.display = 'none';
            }
        }

        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                const original = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = original, 1500);
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = 'Copy', 1500);
            });
        }

        async function exportCredentials() {
            // Use database export endpoint
            if (state.sessionId) {
                await autoDownloadCredentials();
            } else {
                // Fallback to local state
                const data = JSON.stringify(state.credentials, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stackbill-credentials.json';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        async function saveProgress() {
            await saveState();
            // Also save all servers for each step
            for (const stepId of Object.keys(state.servers)) {
                await saveServersToDb(stepId);
            }
            alert('Progress saved to database!');
        }

        // Load global settings from API
        async function loadGlobalSettings() {
            try {
                const response = await fetch('/api/settings');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.settings) {
                        data.settings.forEach(setting => {
                            if (setting.key === 'auto_cleanup') {
                                globalSettings.autoCleanup = setting.value === 'true' || setting.value === '1';
                            }
                        });
                    }
                }
            } catch (e) {
                console.log('Could not load global settings, using defaults');
            }
        }

        // Start a new session (clear current and create fresh)
        async function startNewSession() {
            if (!confirm('This will start a new deployment session. Your current progress will remain in the database. Continue?')) {
                return;
            }

            // Clear local state
            state.completedSteps = new Set();
            state.credentials = {};
            state.stepData = {};
            state.servers = {};
            state.modes = { mysql: 'single', mongodb: 'single' };
            state.sslConfig = { type: 'letsencrypt', domain: '', certificate: '', privateKey: '' };
            state.nfsConfig = { diskDevice: '', clientIpRange: '*' };
            state.loadBalancerConfig = { type: 'haproxy', backendPort: '30080' };
            state.currentStep = 0;
            state.automationMode = 'manual';

            // Create new session
            await createNewSession('Deployment Session ' + new Date().toLocaleDateString());

            // Update URL with new session ID
            const newUrl = `${window.location.pathname}?session=${state.sessionId}`;
            window.history.replaceState({}, '', newUrl);

            // Update header display
            updateSessionDisplay();

            // Re-render UI
            renderProgressSteps();
            renderStepCards();
            renderSummary();
            closePanel();

            showToast('New session started!');
        }

        // Delete current session and start fresh
        async function deleteCurrentSession() {
            if (!confirm('This will permanently delete the current session and all its data. This cannot be undone. Continue?')) {
                return;
            }

            if (state.sessionId) {
                try {
                    await fetch(`/api/sessions/${state.sessionId}`, { method: 'DELETE' });
                } catch (e) {
                    console.error('Failed to delete session:', e);
                }
            }

            localStorage.removeItem('stackbill_session_id');
            // Redirect to sessions page
            window.location.href = '/sessions.html';
        }

        // Share session - shows the share modal
        async function shareSession() {
            if (!state.sessionId) {
                showToast('No active session to share');
                return;
            }

            // First, save current state to ensure it's up to date
            await saveState();

            const shareUrl = `${window.location.origin}/index.html?session=${state.sessionId}`;
            document.getElementById('shareUrl').value = shareUrl;

            // Render share details
            renderShareDetails();
            generateFullDetailsText(shareUrl);

            // Show modal
            document.getElementById('shareModal').classList.add('active');
        }

        function hideShareModal() {
            document.getElementById('shareModal').classList.remove('active');
            document.getElementById('fullDetailsContainer').classList.add('hidden');
        }

        function renderShareDetails() {
            const completedCount = state.completedSteps.size;
            const totalSteps = DEPLOYMENT_STEPS.length;
            const currentStepIndex = state.currentStep || 0;
            const currentStep = DEPLOYMENT_STEPS[currentStepIndex] || DEPLOYMENT_STEPS[0];

            let serverCount = 0;
            Object.values(state.servers).forEach(stepServers => {
                if (Array.isArray(stepServers)) serverCount += stepServers.length;
            });

            const html = `
                <div class="share-details-grid">
                    <div>
                        <div class="share-detail-label">Session Name</div>
                        <div class="share-detail-value">${escapeHtml(state.sessionName || 'Deployment Session')}</div>
                    </div>
                    <div>
                        <div class="share-detail-label">Progress</div>
                        <div class="share-detail-value">${completedCount} / ${totalSteps} steps</div>
                    </div>
                    <div>
                        <div class="share-detail-label">Current Step</div>
                        <div class="share-detail-value">${currentStep.title}</div>
                    </div>
                    <div>
                        <div class="share-detail-label">Servers</div>
                        <div class="share-detail-value">${serverCount} configured</div>
                    </div>
                    <div>
                        <div class="share-detail-label">Mode</div>
                        <div class="share-detail-value">${state.automationMode === 'auto' ? 'Auto-Complete' : 'Step-by-Step'}</div>
                    </div>
                    <div>
                        <div class="share-detail-label">Session ID</div>
                        <div class="share-detail-value">${state.sessionId ? state.sessionId.substring(0, 8) + '...' : 'N/A'}</div>
                    </div>
                </div>

                <div class="step-badges">
                    ${DEPLOYMENT_STEPS.map((step, idx) => {
                        const isCompleted = state.completedSteps.has(step.id);
                        const isCurrent = idx === currentStepIndex;
                        let badgeClass = 'pending';
                        if (isCompleted) badgeClass = 'completed';
                        else if (isCurrent) badgeClass = 'current';
                        return `<span class="step-badge ${badgeClass}">${step.title}</span>`;
                    }).join('')}
                </div>
            `;

            document.getElementById('shareSessionDetails').innerHTML = html;
        }

        function generateFullDetailsText(shareUrl) {
            const completedCount = state.completedSteps.size;
            const totalSteps = DEPLOYMENT_STEPS.length;
            const progressPct = Math.round((completedCount / totalSteps) * 100);
            const currentStepIndex = state.currentStep || 0;
            const currentStep = DEPLOYMENT_STEPS[currentStepIndex] || DEPLOYMENT_STEPS[0];

            const serverDetails = [];
            Object.entries(state.servers).forEach(([stepId, stepServers]) => {
                if (Array.isArray(stepServers) && stepServers.length > 0) {
                    const step = DEPLOYMENT_STEPS.find(s => s.id === stepId);
                    serverDetails.push(`  ${step?.title || stepId}: ${stepServers.length} server(s)`);
                }
            });

            const text = `
================================================================================
STACKBILL DEPLOYMENT SESSION - SHARE DETAILS
================================================================================

SESSION URL: ${shareUrl}

SESSION INFO:
  Session ID: ${state.sessionId}
  Name: ${state.sessionName || 'Deployment Session'}
  Mode: ${state.automationMode === 'auto' ? 'Auto-Complete' : 'Step-by-Step'}

PROGRESS:
  Current Step: ${currentStep.title} (Step ${currentStepIndex + 1} of ${totalSteps})
  Completed Steps: ${completedCount} / ${totalSteps} (${progressPct}%)

STEP STATUS:
${DEPLOYMENT_STEPS.map((step, idx) => {
    const isCompleted = state.completedSteps.has(step.id);
    const isCurrent = idx === currentStepIndex;
    const status = isCompleted ? '[DONE]' : (isCurrent ? '[CURRENT]' : '[PENDING]');
    return `  ${(idx + 1).toString().padStart(2, ' ')}. ${step.title.padEnd(15)} ${status}`;
}).join('\n')}

CONFIGURED SERVERS:
${serverDetails.length > 0 ? serverDetails.join('\n') : '  No servers configured yet'}

--------------------------------------------------------------------------------
HOW TO CONTINUE:
1. Open the Session URL above in your browser
2. The deployment wizard will load with all saved progress
3. Continue from the current step: ${currentStep.title}
--------------------------------------------------------------------------------

Note: Server passwords are stored encrypted and will be available when you resume.
================================================================================
`.trim();

            document.getElementById('fullDetailsText').value = text;
        }

        async function copyShareUrl() {
            const url = document.getElementById('shareUrl').value;
            try {
                await navigator.clipboard.writeText(url);
                showToast('URL copied to clipboard!');
            } catch (e) {
                fallbackCopy(url);
                showToast('URL copied to clipboard!');
            }
        }

        async function copyFullDetails() {
            document.getElementById('fullDetailsContainer').classList.remove('hidden');
            const text = document.getElementById('fullDetailsText').value;
            try {
                await navigator.clipboard.writeText(text);
                showToast('Full details copied to clipboard!');
            } catch (e) {
                fallbackCopy(text);
                showToast('Full details copied to clipboard!');
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        async function exportFullSession() {
            if (!state.sessionId) {
                showToast('No active session to export');
                return;
            }

            const btn = event.target.closest('button');
            btn.classList.add('btn-loading');

            try {
                const response = await fetch(`/api/sessions/${state.sessionId}/export-full`);
                if (!response.ok) throw new Error(`Export failed: ${response.status}`);

                const exportData = await response.json();
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `stackbill-session-${state.sessionId.substring(0, 8)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Session exported successfully!');
            } catch (e) {
                console.error('Failed to export session:', e);
                showToast('Failed to export session: ' + e.message);
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        // Legacy function for backward compatibility
        async function copySessionUrl() {
            await shareSession();
        }

        // Navigate to sessions page
        function goToSessions() {
            window.location.href = '/sessions.html';
        }

        // Toast notification using the proper toast container
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            const icons = {
                success: '&#10004;',
                error: '&#10006;',
                warning: '&#9888;',
                info: '&#8505;'
            };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
            `;
            toast.className = `toast toast-${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Update session name display in header
        function updateSessionDisplay() {
            const nameDisplay = document.getElementById('sessionNameDisplay');
            if (nameDisplay) {
                const sessionName = state.sessionName || 'Deployment Session';
                nameDisplay.innerHTML = `${sessionName}<span class="edit-icon">&#9998;</span>`;
                nameDisplay.title = `Click to rename (ID: ${state.sessionId || ''})`;
            }
        }

        // Rename session modal functions
        function showRenameSessionModal() {
            const modal = document.getElementById('renameSessionModal');
            const input = document.getElementById('renameSessionInput');
            input.value = state.sessionName || '';
            modal.classList.add('active');
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function hideRenameSessionModal() {
            document.getElementById('renameSessionModal').classList.remove('active');
        }

        async function confirmRenameSession() {
            const newName = document.getElementById('renameSessionInput').value.trim();
            if (!newName) {
                showToast('Please enter a session name');
                return;
            }

            if (!state.sessionId) {
                showToast('No active session');
                return;
            }

            try {
                const response = await fetch(`/api/sessions/${state.sessionId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });

                const data = await response.json();

                if (data.success) {
                    state.sessionName = newName;
                    updateSessionDisplay();
                    renderSummary();
                    showToast('Session renamed successfully');
                } else {
                    showToast('Failed to rename session');
                }
            } catch (e) {
                console.error('Failed to rename session:', e);
                showToast('Failed to rename session');
            }

            hideRenameSessionModal();
        }

        // Handle Enter key in rename modal
        document.getElementById('renameSessionInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmRenameSession();
            }
        });

        // Close rename modal on overlay click
        document.getElementById('renameSessionModal').addEventListener('click', (e) => {
            if (e.target.id === 'renameSessionModal') {
                hideRenameSessionModal();
            }
        });

        // Close share modal on overlay click
        document.getElementById('shareModal').addEventListener('click', (e) => {
            if (e.target.id === 'shareModal') {
                hideShareModal();
            }
        });

        // Keyboard navigation - Escape closes modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Check for active modals and close them
                const shareModal = document.getElementById('shareModal');
                const renameModal = document.getElementById('renameSessionModal');

                if (shareModal.classList.contains('active')) {
                    hideShareModal();
                } else if (renameModal.classList.contains('active')) {
                    hideRenameSessionModal();
                }
            }
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
